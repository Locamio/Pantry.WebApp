{"version":3,"sources":["webpack:///webpack/bootstrap 16273d77e54f50457d22","webpack:///C:/dev/Biz/Pantry.WebApp/src.js/index.es6","webpack:///../~/riot/riot.js","webpack:///C:/dev/Biz/Pantry.WebApp/src.js/stores/todo-store.es6","webpack:///C:/dev/Biz/Pantry.WebApp/src.js/dispatcher.es6","webpack:///./views/eg.tag"],"names":[],"mappings":"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;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;;AAEA,EAAC;;AAED,KAAI,iBAAiB,KAAK;AAC1B;AACA,cAAa,YAAY;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAgC,gBAAgB;AAChD;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA,IAAG;AACH;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAkC,4BAA4B;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAe,uBAAuB;;AAEtC;AACA;AACA;AACA;;AAEA,iCAAgC,iCAAiC;AACjE,kBAAiB,oBAAoB;;AAErC,MAAK;;AAEL;AACA;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAgB,iDAAiD,EAAE;;AAEnE;AACA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+CAA8C,wBAAwB;AACtE;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,sCAAqC,yCAAyC;;AAE9E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA,MAAK;AACL;;AAEA,mBAAkB,OAAO;AACzB,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;AACA,gDAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAuC,yBAAyB;;AAEhE;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA,mCAAkC,YAAY,UAAU;AACxD;AACA;AACA;AACA,oBAAmB;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;;AAEA,oCAAmC,gBAAgB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;;AAGA;AACA,gBAAe;;AAEf;AACA;AACA;AACA;AACA,wBAAuB,cAAc;AACrC;AACA;;AAEA,EAAC;;;;;;;;;;;;AC3vCD,aAAY,CAAC;;;;;sBAIW,SAAS;;;;iCAFhB,CAAM;;;;AAER,UAAS,SAAS,CAAC,UAAU,EAAE;AAC5C,OAAM,gBAAgB,GAAG,WAAW,CAAC;AACrC,qBAAK,UAAU,CAAC,IAAI,CAAC,CAAC;AACtB,OAAI,IAAI,GAAG,IAAI,CAAC;AAChB,OAAI,CAAC,aAAa,GAAG,eAAe,CAAC;AACrC,OAAI,IAAI,GAAG,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;AACzD,OAAI,CAAC,KAAK,GAAI,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAK,EAAE,CAAC;AAC9C,OAAI,CAAC,UAAU,GAAG,UAAU,CAAC;;AAE7B,OAAI,CAAC,OAAO,GAAG,YAAW;;AAExB,WAAM,CAAC,YAAY,CAAC,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;AAC1E,SAAI,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IAClC,CAAC;;;AAGF,OAAI,CAAC,EAAE,CAAC,UAAU,CAAC,QAAQ,EAAE,UAAS,IAAI,EAAE;AAC1C,SAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACtB,SAAI,CAAC,OAAO,EAAE,CAAC;IAChB,CAAC,CAAC;;AAEH,OAAI,CAAC,EAAE,CAAC,UAAU,CAAC,WAAW,EAAE,UAAS,IAAI,EAAE;AAC7C,SAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC;AACvB,SAAI,CAAC,OAAO,EAAE,CAAC;IAChB,CAAC,CAAC;AACH,OAAI,CAAC,EAAE,CAAC,UAAU,CAAC,WAAW,EAAE,YAAW;AACzC,SAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,kBAAQ;cAAI,CAAC,QAAQ,CAAC,IAAI;MAAA,CAAC,CAAC;AAC3D,SAAI,CAAC,OAAO,EAAE,CAAC;IAChB,CAAC,CAAC;;AAEH,OAAI,CAAC,EAAE,CAAC,UAAU,CAAC,UAAU,EAAE,YAAW;AACxC,SAAI,CAAC,OAAO,EAAE,CAAC;IAChB,CAAC;EAGH;;;;;;;;;;;;;ACzCD,OAAM,CAAC,OAAO,GAAG;;;AAGf,WAAQ,EAAE,UAAU;AACpB,cAAW,EAAE,aAAa;AAC1B,cAAW,EAAE,aAAa;AAC1B,aAAU,EAAE,YAAY;;AAExB,UAAO,EAAE,EAAE;;AAEX,WAAQ,oBAAC,KAAK,EAAE;AACd,SAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC;IACzB;;AAED,UAAO,qBAAG;AACR,SAAI,IAAI,GAAG,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AACpC,YAAO,CAAC,GAAG,CAAC,uBAAuB,GAAG,IAAI,CAAC,CAAC;AAC5C,SAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAS,EAAE,EAAE;AAChC,SAAE,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;MAC7B,CAAC;IACH;;AAED,KAAE,cAAC,EAAE,EAAE,EAAE,EAAE;AACT,SAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAS,EAAE,EAAE;AAChC,SAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;MACd,CAAC;IACH;;AAED,MAAG,eAAC,EAAE,EAAE,EAAE,EAAE;AACV,SAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAS,EAAE,EAAE;AAChC,WAAI,EAAE,EACJ,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,KAEf,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC;MACb,CAAC;IACH;;AAED,MAAG,eAAC,EAAE,EAAE,EAAE,EAAE;AACV,SAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAS,EAAE,EAAE;AAChC,SAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;MACf,CAAC;IACH;;EAEF,C;;;;;;AC9CD;;AAEA,wCAAuC,uBAAuB,YAAY,OAAO,MAAM,gBAAgB,eAAe,UAAU,8BAA8B,YAAY,cAAc,GAAG,MAAM,iBAAiB,2BAA2B,YAAY,OAAO,MAAM;;AAEtQ;AACA;AACA;AACA;AACA;AACA,wBAAuB,iBAAiB;AACxC;AACA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;;;AAGT,EAAC,E","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 16273d77e54f50457d22\n **/","/*\r\nWhats this stuff do?\r\n */\r\n'use strict';\r\n\r\nimport riot from 'riot';\r\nimport TodoStore from './stores/todo-store.es6';\r\nimport dispatcher from './dispatcher.es6';\r\nimport './views/eg.tag'\r\n\r\nlet todoStore = new TodoStore(dispatcher);\r\ndispatcher.addStore(todoStore);\r\nriot.mount('todo-app', {store: todoStore});\n\n\n/** WEBPACK FOOTER **\n ** C:/dev/Biz/Pantry.WebApp/src.js/index.es6\n **/","/* Riot v2.1.0, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function(window) {\n  // 'use strict' does not allow us to override the events properties https://github.com/muut/riotjs/blob/dev/lib/tag/update.js#L7-L10\n  // it leads to the following error on firefox \"setting a property that has only a getter\"\n  //'use strict'\n\n\n  var riot = { version: 'v2.1.0', settings: {} }\n\n\nriot.observable = function(el) {\n\n  el = el || {}\n\n  var callbacks = {},\n      _id = 0\n\n  el.on = function(events, fn) {\n    if (typeof fn == 'function') {\n      fn._id = typeof fn._id == 'undefined' ? _id++ : fn._id\n\n      events.replace(/\\S+/g, function(name, pos) {\n        (callbacks[name] = callbacks[name] || []).push(fn)\n        fn.typed = pos > 0\n      })\n    }\n    return el\n  }\n\n  el.off = function(events, fn) {\n    if (events == '*') callbacks = {}\n    else {\n      events.replace(/\\S+/g, function(name) {\n        if (fn) {\n          var arr = callbacks[name]\n          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {\n            if (cb._id == fn._id) { arr.splice(i, 1); i-- }\n          }\n        } else {\n          callbacks[name] = []\n        }\n      })\n    }\n    return el\n  }\n\n  // only single event supported\n  el.one = function(name, fn) {\n    function on() {\n      el.off(name, on)\n      fn.apply(el, arguments)\n    }\n    return el.on(name, on)\n  }\n\n  el.trigger = function(name) {\n    var args = [].slice.call(arguments, 1),\n        fns = callbacks[name] || []\n\n    for (var i = 0, fn; (fn = fns[i]); ++i) {\n      if (!fn.busy) {\n        fn.busy = 1\n        fn.apply(el, fn.typed ? [name].concat(args) : args)\n        if (fns[i] !== fn) { i-- }\n        fn.busy = 0\n      }\n    }\n\n    if (callbacks.all && name != 'all') {\n      el.trigger.apply(el, ['all', name].concat(args))\n    }\n\n    return el\n  }\n\n  return el\n\n}\nriot.mixin = (function() {\n  var registeredMixins = {}\n  return function(name, mixin) {\n    if (!mixin) return registeredMixins[name]\n      else registeredMixins[name] = mixin\n  }\n})()\n\n;(function(riot, evt, window) {\n\n  // browsers only\n  if (!window) return\n\n  var loc = window.location,\n      fns = riot.observable(),\n      win = window,\n      started = false,\n      current\n\n  function hash() {\n    return loc.href.split('#')[1] || ''\n  }\n\n  function parser(path) {\n    return path.split('/')\n  }\n\n  function emit(path) {\n    if (path.type) path = hash()\n\n    if (path != current) {\n      fns.trigger.apply(null, ['H'].concat(parser(path)))\n      current = path\n    }\n  }\n\n  var r = riot.route = function(arg) {\n    // string\n    if (arg[0]) {\n      loc.hash = arg\n      emit(arg)\n\n    // function\n    } else {\n      fns.on('H', arg)\n    }\n  }\n\n  r.exec = function(fn) {\n    fn.apply(null, parser(hash()))\n  }\n\n  r.parser = function(fn) {\n    parser = fn\n  }\n\n  r.stop = function () {\n    if (!started) return\n    win.removeEventListener ? win.removeEventListener(evt, emit, false) : win.detachEvent('on' + evt, emit)\n    fns.off('*')\n    started = false\n  }\n\n  r.start = function () {\n    if (started) return\n    win.addEventListener ? win.addEventListener(evt, emit, false) : win.attachEvent('on' + evt, emit)\n    started = true\n  }\n\n  // autostart the router\n  r.start()\n\n})(riot, 'hashchange', window)\n/*\n\n//// How it works?\n\n\nThree ways:\n\n1. Expressions: tmpl('{ value }', data).\n   Returns the result of evaluated expression as a raw object.\n\n2. Templates: tmpl('Hi { name } { surname }', data).\n   Returns a string with evaluated expressions.\n\n3. Filters: tmpl('{ show: !done, highlight: active }', data).\n   Returns a space separated list of trueish keys (mainly\n   used for setting html classes), e.g. \"show highlight\".\n\n\n// Template examples\n\ntmpl('{ title || \"Untitled\" }', data)\ntmpl('Results are { results ? \"ready\" : \"loading\" }', data)\ntmpl('Today is { new Date() }', data)\ntmpl('{ message.length > 140 && \"Message is too long\" }', data)\ntmpl('This item got { Math.round(rating) } stars', data)\ntmpl('<h1>{ title }</h1>{ body }', data)\n\n\n// Falsy expressions in templates\n\nIn templates (as opposed to single expressions) all falsy values\nexcept zero (undefined/null/false) will default to empty string:\n\ntmpl('{ undefined } - { false } - { null } - { 0 }', {})\n// will return: \" - - - 0\"\n\n*/\n\n\nvar brackets = (function(orig, s, b) {\n  return function(x) {\n\n    // make sure we use the current setting\n    s = riot.settings.brackets || orig\n    if (b != s) b = s.split(' ')\n\n    // if regexp given, rewrite it with current brackets (only if differ from default)\n    return x && x.test\n      ? s == orig\n        ? x : RegExp(x.source\n                      .replace(/\\{/g, b[0].replace(/(?=.)/g, '\\\\'))\n                      .replace(/\\}/g, b[1].replace(/(?=.)/g, '\\\\')),\n                    x.global ? 'g' : '')\n\n      // else, get specific bracket\n      : b[x]\n\n  }\n})('{ }')\n\n\nvar tmpl = (function() {\n\n  var cache = {},\n      reVars = /(['\"\\/]).*?[^\\\\]\\1|\\.\\w*|\\w*:|\\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\\b|function *\\()|([a-z_$]\\w*)/gi\n              // [ 1               ][ 2  ][ 3 ][ 4                                                                                  ][ 5       ]\n              // find variable names:\n              // 1. skip quoted strings and regexps: \"a b\", 'a b', 'a \\'b\\'', /a b/\n              // 2. skip object properties: .name\n              // 3. skip object literals: name:\n              // 4. skip javascript keywords\n              // 5. match var name\n\n  // build a template (or get it from cache), render with data\n  return function(str, data) {\n    return str && (cache[str] = cache[str] || tmpl(str))(data)\n  }\n\n\n  // create a template instance\n\n  function tmpl(s, p) {\n\n    // default template string to {}\n    s = (s || (brackets(0) + brackets(1)))\n\n      // temporarily convert \\{ and \\} to a non-character\n      .replace(brackets(/\\\\{/g), '\\uFFF0')\n      .replace(brackets(/\\\\}/g), '\\uFFF1')\n\n    // split string to expression and non-expresion parts\n    p = split(s, extract(s, brackets(/{/), brackets(/}/)))\n\n    return new Function('d', 'return ' + (\n\n      // is it a single expression or a template? i.e. {x} or <b>{x}</b>\n      !p[0] && !p[2] && !p[3]\n\n        // if expression, evaluate it\n        ? expr(p[1])\n\n        // if template, evaluate all expressions in it\n        : '[' + p.map(function(s, i) {\n\n            // is it an expression or a string (every second part is an expression)\n          return i % 2\n\n              // evaluate the expressions\n              ? expr(s, true)\n\n              // process string parts of the template:\n              : '\"' + s\n\n                  // preserve new lines\n                  .replace(/\\n/g, '\\\\n')\n\n                  // escape quotes\n                  .replace(/\"/g, '\\\\\"')\n\n                + '\"'\n\n        }).join(',') + '].join(\"\")'\n      )\n\n      // bring escaped { and } back\n      .replace(/\\uFFF0/g, brackets(0))\n      .replace(/\\uFFF1/g, brackets(1))\n\n    + ';')\n\n  }\n\n\n  // parse { ... } expression\n\n  function expr(s, n) {\n    s = s\n\n      // convert new lines to spaces\n      .replace(/\\n/g, ' ')\n\n      // trim whitespace, brackets, strip comments\n      .replace(brackets(/^[{ ]+|[ }]+$|\\/\\*.+?\\*\\//g), '')\n\n    // is it an object literal? i.e. { key : value }\n    return /^\\s*[\\w- \"']+ *:/.test(s)\n\n      // if object literal, return trueish keys\n      // e.g.: { show: isOpen(), done: item.done } -> \"show done\"\n      ? '[' +\n\n          // extract key:val pairs, ignoring any nested objects\n          extract(s,\n\n              // name part: name:, \"name\":, 'name':, name :\n              /[\"' ]*[\\w- ]+[\"' ]*:/,\n\n              // expression part: everything upto a comma followed by a name (see above) or end of line\n              /,(?=[\"' ]*[\\w- ]+[\"' ]*:)|}|$/\n              ).map(function(pair) {\n\n                // get key, val parts\n                return pair.replace(/^[ \"']*(.+?)[ \"']*: *(.+?),? *$/, function(_, k, v) {\n\n                  // wrap all conditional parts to ignore errors\n                  return v.replace(/[^&|=!><]+/g, wrap) + '?\"' + k + '\":\"\",'\n\n                })\n\n              }).join('')\n\n        + '].join(\" \").trim()'\n\n      // if js expression, evaluate as javascript\n      : wrap(s, n)\n\n  }\n\n\n  // execute js w/o breaking on errors or undefined vars\n\n  function wrap(s, nonull) {\n    s = s.trim()\n    return !s ? '' : '(function(v){try{v='\n\n        // prefix vars (name => data.name)\n        + (s.replace(reVars, function(s, _, v) { return v ? '(d.'+v+'===undefined?'+(typeof window == 'undefined' ? 'global.' : 'window.')+v+':d.'+v+')' : s })\n\n          // break the expression if its empty (resulting in undefined value)\n          || 'x')\n      + '}catch(e){'\n      + '}finally{return '\n\n        // default to empty string for falsy values except zero\n        + (nonull === true ? '!v&&v!==0?\"\":v' : 'v')\n\n      + '}}).call(d)'\n  }\n\n\n  // split string by an array of substrings\n\n  function split(str, substrings) {\n    var parts = []\n    substrings.map(function(sub, i) {\n\n      // push matched expression and part before it\n      i = str.indexOf(sub)\n      parts.push(str.slice(0, i), sub)\n      str = str.slice(i + sub.length)\n    })\n\n    // push the remaining part\n    return parts.concat(str)\n  }\n\n\n  // match strings between opening and closing regexp, skipping any inner/nested matches\n\n  function extract(str, open, close) {\n\n    var start,\n        level = 0,\n        matches = [],\n        re = new RegExp('('+open.source+')|('+close.source+')', 'g')\n\n    str.replace(re, function(_, open, close, pos) {\n\n      // if outer inner bracket, mark position\n      if(!level && open) start = pos\n\n      // in(de)crease bracket level\n      level += open ? 1 : -1\n\n      // if outer closing bracket, grab the match\n      if(!level && close != null) matches.push(str.slice(start, pos+close.length))\n\n    })\n\n    return matches\n  }\n\n})()\n\n// { key, i in items} -> { key, i, items }\nfunction loopKeys(expr) {\n  var ret = { val: expr },\n      els = expr.split(/\\s+in\\s+/)\n\n  if (els[1]) {\n    ret.val = brackets(0) + els[1]\n    els = els[0].slice(brackets(0).length).trim().split(/,\\s*/)\n    ret.key = els[0]\n    ret.pos = els[1]\n  }\n\n  return ret\n}\n\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n\n/* Beware: heavy stuff */\nfunction _each(dom, parent, expr) {\n\n  remAttr(dom, 'each')\n\n  var template = dom.outerHTML,\n      prev = dom.previousSibling,\n      root = dom.parentNode,\n      rendered = [],\n      tags = [],\n      checksum\n\n  expr = loopKeys(expr)\n\n  function add(pos, item, tag) {\n    rendered.splice(pos, 0, item)\n    tags.splice(pos, 0, tag)\n  }\n\n  // clean template code\n  parent.one('update', function() {\n    root.removeChild(dom)\n\n  }).one('premount', function() {\n    if (root.stub) root = parent.root\n\n  }).on('update', function() {\n\n    var items = tmpl(expr.val, parent)\n    if (!items) return\n\n    // object loop. any changes cause full redraw\n    if (!Array.isArray(items)) {\n      var testsum = JSON.stringify(items)\n\n      if (testsum == checksum) return\n      checksum = testsum\n\n      // clear old items\n      each(tags, function(tag) { tag.unmount() })\n      rendered = []\n      tags = []\n\n      items = Object.keys(items).map(function(key) {\n        return mkitem(expr, key, items[key])\n      })\n\n    }\n\n    // unmount redundant\n    each(rendered, function(item) {\n      if (item instanceof Object) {\n        // skip existing items\n        if (items.indexOf(item) > -1) {\n          return\n        }\n      } else {\n        // find all non-objects\n        var newItems = arrFindEquals(items, item),\n            oldItems = arrFindEquals(rendered, item)\n\n        // if more or equal amount, no need to remove\n        if (newItems.length >= oldItems.length) {\n          return\n        }\n      }\n      var pos = rendered.indexOf(item),\n          tag = tags[pos]\n\n      if (tag) {\n        tag.unmount()\n        rendered.splice(pos, 1)\n        tags.splice(pos, 1)\n        // to let \"each\" know that this item is removed\n        return false\n      }\n\n    })\n\n    // mount new / reorder\n    var prevBase = [].indexOf.call(root.childNodes, prev) + 1\n    each(items, function(item, i) {\n\n      // start index search from position based on the current i\n      var pos = items.indexOf(item, i),\n          oldPos = rendered.indexOf(item, i)\n\n      // if not found, search backwards from current i position\n      pos < 0 && (pos = items.lastIndexOf(item, i))\n      oldPos < 0 && (oldPos = rendered.lastIndexOf(item, i))\n\n      if (!(item instanceof Object)) {\n        // find all non-objects\n        var newItems = arrFindEquals(items, item),\n            oldItems = arrFindEquals(rendered, item)\n\n        // if more, should mount one new\n        if (newItems.length > oldItems.length) {\n          oldPos = -1\n        }\n      }\n\n      // mount new\n      var nodes = root.childNodes\n      if (oldPos < 0) {\n        if (!checksum && expr.key) var _item = mkitem(expr, item, pos)\n\n        var tag = new Tag({ tmpl: template }, {\n          before: nodes[prevBase + pos],\n          parent: parent,\n          root: root,\n          item: _item || item\n        })\n\n        tag.mount()\n\n        add(pos, item, tag)\n        return true\n      }\n\n      // change pos value\n      if (expr.pos && tags[oldPos][expr.pos] != pos) {\n        tags[oldPos].one('update', function(item) {\n          item[expr.pos] = pos\n        })\n        tags[oldPos].update()\n      }\n\n      // reorder\n      if (pos != oldPos) {\n        root.insertBefore(nodes[prevBase + oldPos], nodes[prevBase + (pos > oldPos ? pos + 1 : pos)])\n        return add(pos, rendered.splice(oldPos, 1)[0], tags.splice(oldPos, 1)[0])\n      }\n\n    })\n\n    rendered = items.slice()\n\n  }).one('updated', function() {\n    walk(root, function(dom) {\n      each(dom.attributes, function(attr) {\n        if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom\n      })\n    })\n  })\n\n}\n\n\nfunction parseNamedElements(root, parent, childTags) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = 0\n      if(dom.parentNode && dom.parentNode.isLoop) dom.isLoop = 1\n      if(dom.getAttribute('each')) dom.isLoop = 1\n      // custom child tag\n      var child = getTag(dom)\n\n      if (child && !dom.isLoop) {\n        var tag = new Tag(child, { root: dom, parent: parent }, dom.innerHTML),\n            namedTag = dom.getAttribute('name'),\n            tagName = namedTag && namedTag.indexOf(brackets(0)) < 0 ? namedTag : child.name,\n            ptag = parent,\n            cachedTag\n\n        while(!getTag(ptag.root)) {\n          if(!ptag.parent) break\n          ptag = ptag.parent\n        }\n        // fix for the parent attribute in the looped elements\n        tag.parent = ptag\n\n        cachedTag = ptag.tags[tagName]\n\n        // if there are multiple children tags having the same name\n        if (cachedTag) {\n          // if the parent tags property is not yet an array\n          // create it adding the first cached tag\n          if (!Array.isArray(cachedTag))\n            ptag.tags[tagName] = [cachedTag]\n          // add the new nested tag to the array\n          ptag.tags[tagName].push(tag)\n        } else {\n          ptag.tags[tagName] = tag\n        }\n\n        // empty the child node once we got its template\n        // to avoid that its children get compiled multiple times\n        dom.innerHTML = ''\n        childTags.push(tag)\n      }\n\n      if(!dom.isLoop)\n        each(dom.attributes, function(attr) {\n          if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom\n        })\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (val.indexOf(brackets(0)) >= 0) {\n      var expr = { dom: dom, expr: val }\n      expressions.push(extend(expr, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = dom.getAttribute('each')\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n      opts = inherit(conf.opts) || {},\n      dom = mkdom(impl.tmpl),\n      parent = conf.parent,\n      expressions = [],\n      childTags = [],\n      root = conf.root,\n      item = conf.item,\n      fn = impl.fn,\n      tagName = root.tagName.toLowerCase(),\n      attr = {},\n      loopDom,\n      TAG_ATTRIBUTES = /([\\w\\-]+)\\s?=\\s?['\"]([^'\"]+)[\"']/gim\n\n  if (fn && root._tag) {\n    root._tag.unmount(true)\n  }\n\n  if(impl.attrs) {\n    var attrs = impl.attrs.match(TAG_ATTRIBUTES)\n\n    each(attrs, function(a) {\n      var kv = a.split(/\\s?=\\s?/)\n      root.setAttribute(kv[0], kv[1].replace(/['\"]/g, ''))\n    })\n\n  }\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  this._id = fastAbs(~~(new Date().getTime() * Math.random()))\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    attr[el.name] = el.value\n  })\n\n\n  if (dom.innerHTML && !/select/.test(tagName) && !/tbody/.test(tagName) && !/tr/.test(tagName))\n    // replace all the yield tags with the tag inner html\n    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\n\n  // options\n  function updateOpts() {\n    each(Object.keys(attr), function(name) {\n      opts[name] = tmpl(attr[name], parent || self)\n    })\n  }\n\n  this.update = function(data, init) {\n    extend(self, data, item)\n    updateOpts()\n    self.trigger('update', item)\n    update(expressions, self, item)\n    self.trigger('updated')\n  }\n\n  this.mixin = function() {\n    each(arguments, function(mix) {\n      mix = 'string' == typeof mix ? riot.mixin(mix) : mix\n      each(Object.keys(mix), function(key) {\n        // bind methods to self\n        if ('init' != key)\n          self[key] = 'function' == typeof mix[key] ? mix[key].bind(self) : mix[key]\n      })\n      // init method will be called automatically\n      if (mix.init) mix.init.bind(self)()\n    })\n  }\n\n  this.mount = function() {\n\n    updateOpts()\n\n    // initialiation\n    fn && fn.call(self, opts)\n\n    toggle(true)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    if (!self.parent) self.update()\n\n    // internal use only, fixes #403\n    self.trigger('premount')\n\n    if (fn) {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n\n    } else {\n      loopDom = dom.firstChild\n      root.insertBefore(loopDom, conf.before || null) // null needed for IE8\n    }\n\n    if (root.stub) self.root = root = parent.root\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent) self.trigger('mount')\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() { self.trigger('mount') })\n  }\n\n\n  this.unmount = function(keepRootTag) {\n    var el = fn ? root : loopDom,\n        p = el.parentNode\n\n    if (p) {\n\n      if (parent) {\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (Array.isArray(parent.tags[tagName])) {\n          each(parent.tags[tagName], function(tag, i) {\n            if (tag._id == self._id)\n              parent.tags[tagName].splice(i, 1)\n          })\n        } else\n          // otherwise just delete the tag instance\n          parent.tags[tagName] = undefined\n      } else {\n        while (el.firstChild) el.removeChild(el.firstChild)\n      }\n\n      if (!keepRootTag)\n        p.removeChild(el)\n\n    }\n\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    // somehow ie8 does not like `delete root._tag`\n    root._tag = null\n\n  }\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (parent) {\n      var evt = isMount ? 'on' : 'off'\n      parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n    }\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n\n}\n\nfunction setEventHandler(name, handler, dom, tag, item) {\n\n  dom[name] = function(e) {\n\n    // cross browser event fix\n    e = e || window.event\n    e.which = e.which || e.charCode || e.keyCode\n    e.target = e.target || e.srcElement\n    e.currentTarget = dom\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      e.preventDefault && e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      var el = item ? tag.parent : tag\n      el.update()\n    }\n\n  }\n\n}\n\n// used by if- attribute\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\n// item = currently looped item\nfunction update(expressions, tag, item) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n        attrName = expr.attr,\n        value = tmpl(expr.expr, tag),\n        parent = expr.dom.parentNode\n\n    if (value == null) value = ''\n\n    // leave out riot- prefixes from strings inside textarea\n    if (parent && parent.tagName == 'TEXTAREA') value = value.replace(/riot-/g, '')\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attrName) return dom.nodeValue = value.toString()\n\n    // remove original attribute\n    remAttr(dom, attrName)\n\n    // event handler\n    if (typeof value == 'function') {\n      setEventHandler(attrName, value, dom, tag, item)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub\n\n      // add to DOM\n      if (value) {\n        stub && insertTo(stub.parentNode, stub, dom)\n\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        insertTo(dom.parentNode, dom, stub)\n      }\n\n    // show / hide\n    } else if (/^(show|hide)$/.test(attrName)) {\n      if (attrName == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // field value\n    } else if (attrName == 'value') {\n      dom.value = value\n\n    // <img src=\"{ expr }\">\n    } else if (attrName.slice(0, 5) == 'riot-') {\n      attrName = attrName.slice(5)\n      value ? dom.setAttribute(attrName, value) : remAttr(dom, attrName)\n\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value\n        if (!value) return\n        value = attrName\n      }\n\n      if (typeof value != 'object') dom.setAttribute(attrName, value)\n\n    }\n\n  })\n\n}\n\nfunction each(els, fn) {\n  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n    el = els[i]\n    // return false -> remove current item during loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\nfunction fastAbs(nr) {\n  return (nr ^ (nr >> 31)) - (nr >> 31)\n}\n\n// max 2 from objects allowed\nfunction extend(obj, from, from2) {\n  from && each(Object.keys(from), function(key) {\n    obj[key] = from[key]\n  })\n  return from2 ? extend(obj, from2) : obj\n}\n\nfunction checkIE() {\n  if (window) {\n    var ua = navigator.userAgent\n    var msie = ua.indexOf('MSIE ')\n    if (msie > 0) {\n      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n    }\n    else {\n      return 0\n    }\n  }\n}\n\nfunction optionInnerHTML(el, html) {\n  var opt = document.createElement('option'),\n      valRegx = /value=[\\\"'](.+?)[\\\"']/,\n      selRegx = /selected=[\\\"'](.+?)[\\\"']/,\n      valuesMatch = html.match(valRegx),\n      selectedMatch = html.match(selRegx)\n\n  opt.innerHTML = html\n\n  if (valuesMatch) {\n    opt.value = valuesMatch[1]\n  }\n\n  if (selectedMatch) {\n    opt.setAttribute('riot-selected', selectedMatch[1])\n  }\n\n  el.appendChild(opt)\n}\n\nfunction tbodyInnerHTML(el, html, tagName) {\n  var div = document.createElement('div')\n  div.innerHTML = '<table>' + html + '</table>'\n\n  if (/td|th/.test(tagName)) {\n    el.appendChild(div.firstChild.firstChild.firstChild.firstChild)\n  } else {\n    el.appendChild(div.firstChild.firstChild.firstChild)\n  }\n}\n\nfunction mkdom(template) {\n  var tagName = template.trim().slice(1, 3).toLowerCase(),\n      rootTag = /td|th/.test(tagName) ? 'tr' : tagName == 'tr' ? 'tbody' : 'div',\n      el = mkEl(rootTag)\n\n  el.stub = true\n\n  if (tagName === 'op' && ieVersion && ieVersion < 10) {\n    optionInnerHTML(el, template)\n  } else if ((rootTag === 'tbody' || rootTag === 'tr') && ieVersion && ieVersion < 10) {\n    tbodyInnerHTML(el, template, tagName)\n  } else\n    el.innerHTML = template\n\n  return el\n}\n\nfunction walk(dom, fn) {\n  if (dom) {\n    if (fn(dom) === false) walk(dom.nextSibling, fn)\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\nfunction replaceYield (tmpl, innerHTML) {\n  return tmpl.replace(/<(yield)\\/?>(<\\/\\1>)?/gim, innerHTML || '')\n}\n\nfunction $$(selector, ctx) {\n  ctx = ctx || document\n  return ctx.querySelectorAll(selector)\n}\n\nfunction arrDiff(arr1, arr2) {\n  return arr1.filter(function(el) {\n    return arr2.indexOf(el) < 0\n  })\n}\n\nfunction arrFindEquals(arr, el) {\n  return arr.filter(function (_el) {\n    return _el === el\n  })\n}\n\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n/**\n *\n * Hacks needed for the old internet explorer versions [lower than IE10]\n *\n */\n\nvar ieVersion = checkIE()\n\nfunction checkIE() {\n  if (window) {\n    var ua = navigator.userAgent\n    var msie = ua.indexOf('MSIE ')\n    if (msie > 0) {\n      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n    }\n    else {\n      return 0\n    }\n  }\n}\n\nfunction tbodyInnerHTML(el, html, tagName) {\n  var div = mkEl('div'),\n      loops = /td|th/.test(tagName) ? 3 : 2,\n      child\n\n  div.innerHTML = '<table>' + html + '</table>'\n  child = div.firstChild\n\n  while(loops--) {\n    child = child.firstChild\n  }\n\n  el.appendChild(child)\n\n}\n\nfunction optionInnerHTML(el, html) {\n  var opt = mkEl('option'),\n      valRegx = /value=[\\\"'](.+?)[\\\"']/,\n      selRegx = /selected=[\\\"'](.+?)[\\\"']/,\n      valuesMatch = html.match(valRegx),\n      selectedMatch = html.match(selRegx)\n\n  opt.innerHTML = html\n\n  if (valuesMatch) {\n    opt.value = valuesMatch[1]\n  }\n\n  if (selectedMatch) {\n    opt.setAttribute('riot-selected', selectedMatch[1])\n  }\n\n  el.appendChild(opt)\n}\n\n/*\n Virtual dom is an array of custom tags on the document.\n Updates and unmounts propagate downwards from parent to children.\n*/\n\nvar virtualDom = [],\n    tagImpl = {},\n    styleNode\n\n\nfunction getTag(dom) {\n  return tagImpl[dom.getAttribute('riot-tag') || dom.tagName.toLowerCase()]\n}\n\nfunction injectStyle(css) {\n\n  styleNode = styleNode || mkEl('style')\n\n  if (!document.head) return\n\n  if(styleNode.styleSheet)\n    styleNode.styleSheet.cssText += css\n  else\n    styleNode.innerHTML += css\n\n  if (!styleNode._rendered)\n    if (styleNode.styleSheet)\n      document.body.appendChild(styleNode)\n    else\n      document.head.appendChild(styleNode)\n\n  styleNode._rendered = true\n\n}\n\nfunction mountTo(root, tagName, opts) {\n  var tag = tagImpl[tagName],\n      innerHTML = root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    virtualDom.push(tag)\n    return tag.on('unmount', function() {\n      virtualDom.splice(virtualDom.indexOf(tag), 1)\n    })\n  }\n\n}\n\nriot.tag = function(name, html, css, attrs, fn) {\n  if (typeof attrs == 'function') {\n    fn = attrs\n    if(/^[\\w\\-]+\\s?=/.test(css)) {attrs = css; css = ''} else attrs = ''\n  }\n  if (typeof css == 'function') fn = css\n  else if (css) injectStyle(css)\n  tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\nriot.mount = function(selector, tagName, opts) {\n\n  var el,\n      selctAllTags = function() {\n        var keys = Object.keys(tagImpl)\n        var list = keys.join(', ')\n        each(keys, function(t) {\n          list += ', *[riot-tag=\"'+ t.trim() + '\"]'\n        })\n        return list\n      },\n      allTags,\n      tags = []\n\n  if (typeof tagName == 'object') { opts = tagName; tagName = 0 }\n\n  // crawl the DOM to find the tag\n  if(typeof selector == 'string') {\n    if (selector == '*') {\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selctAllTags()\n    } else {\n      selector.split(',').map(function(t) {\n        selector += ', *[riot-tag=\"'+ t.trim() + '\"]'\n      })\n\n    }\n    // or just the ones named like the selector\n    el = $$(selector)\n  }\n  // probably you have passed already a tag or a NodeList\n  else\n    el = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName == '*') {\n    // get all custom tags\n    tagName = allTags || selctAllTags()\n    // if the root el it's just a single tag\n    if (el.tagName) {\n      el = $$(tagName, el)\n    } else {\n      var nodeList = []\n      // select all the children for all the different root elements\n      each(el, function(tag) {\n        nodeList = $$(tagName, tag)\n      })\n      el = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  function push(root) {\n    if(tagName && !root.getAttribute('riot-tag')) root.setAttribute('riot-tag', tagName)\n\n    var name = tagName || root.getAttribute('riot-tag') || root.tagName.toLowerCase(),\n        tag = mountTo(root, name, opts)\n\n    if (tag) tags.push(tag)\n  }\n\n  // DOM node\n  if (el.tagName)\n    push(selector)\n  // selector or NodeList\n  else\n    each(el, push)\n\n  return tags\n\n}\n\n// update everything\nriot.update = function() {\n  return each(virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n// @deprecated\nriot.mountTo = riot.mount\n\n\n  // share methods for other riot parts, e.g. compiler\n  riot.util = { brackets: brackets, tmpl: tmpl }\n\n  // support CommonJS, AMD & browser\n  if (typeof exports === 'object')\n    module.exports = riot\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return riot })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : undefined);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/riot/riot.js\n ** module id = 1\n ** module chunks = 0\n **/","// TodoStore definition.\r\n// Flux stores house application logic and state that relate to a specific domain.\r\n// The store responds to relevant events emitted by the flux dispatcher.\r\n// The store emits change events to any listening views, so that they may react\r\n// and redraw themselves.\r\n'use strict';\r\n\r\nimport Riot from 'riot';\r\n\r\nexport default function TodoStore(dispatcher) {\r\n  const LOCALSTORAGE_KEY = 'riot-todo';\r\n  Riot.observable(this); // Riot provides our event emitter.\r\n  var self = this;\r\n  this.CHANGED_EVENT = 'CHANGED_EVENT';\r\n  var json = window.localStorage.getItem(LOCALSTORAGE_KEY);\r\n  this.todos = (json && JSON.parse(json)) || [];\r\n  this.dispatcher = dispatcher;\r\n\r\n  this.changed = function() {\r\n    // Brute force update all.\r\n    window.localStorage.setItem(LOCALSTORAGE_KEY, JSON.stringify(this.todos));\r\n    this.trigger(this.CHANGED_EVENT);\r\n  };\r\n\r\n  // Event handlers.\r\n  self.on(dispatcher.ADD_TODO, function(todo) {\r\n    self.todos.push(todo);\r\n    self.changed();\r\n  });\r\n\r\n  self.on(dispatcher.TOGGLE_TODO, function(todo) {\r\n    todo.done = !todo.done;\r\n    self.changed();\r\n  });\r\n  self.on(dispatcher.CLEAR_TODOS, function() {\r\n    self.todos = self.todos.filter(todoItem => !todoItem.done);\r\n    self.changed();\r\n  });\r\n\r\n  self.on(dispatcher.INIT_TODOS, function() {\r\n    self.changed();\r\n  })\r\n\r\n\r\n}\n\n\n/** WEBPACK FOOTER **\n ** C:/dev/Biz/Pantry.WebApp/src.js/stores/todo-store.es6\n **/","// RiotControl dispatcher with Todo actions and formatted as node commonjs module.\r\n// https://github.com/jimsparkman/RiotControl\r\n\r\nmodule.exports = {\r\n\r\n  // Dispatcher actions.\r\n  ADD_TODO: 'ADD_TODO',\r\n  TOGGLE_TODO: 'TOGGLE_TODO',\r\n  CLEAR_TODOS: 'CLEAR_TODOS',\r\n  INIT_TODOS: 'INIT_TODOS',\r\n\r\n  _stores: [],\r\n\r\n  addStore(store) {\r\n    this._stores.push(store)\r\n  },\r\n\r\n  trigger() {\r\n    var args = [].slice.call(arguments);\r\n    console.log('dispatcher: trigger: ' + args);\r\n    this._stores.forEach(function(el) {\r\n      el.trigger.apply(null, args)\r\n    })\r\n  },\r\n\r\n  on(ev, cb) {\r\n    this._stores.forEach(function(el) {\r\n      el.on(ev, cb)\r\n    })\r\n  },\r\n\r\n  off(ev, cb) {\r\n    this._stores.forEach(function(el) {\r\n      if (cb)\r\n        el.off(ev, cb);\r\n      else\r\n        el.off(ev)\r\n    })\r\n  },\r\n\r\n  one(ev, cb) {\r\n    this._stores.forEach(function(el) {\r\n      el.one(ev, cb)\r\n    })\r\n  }\r\n\r\n};\n\n\n/** WEBPACK FOOTER **\n ** C:/dev/Biz/Pantry.WebApp/src.js/dispatcher.es6\n **/","var riot = require(\"riot\");\n\nriot.tag('paginator', '<ul><li class=\"{ disabled: current==1 }\" onclick=\"{ prev }\">&lt;</li><li each=\"{ num in range }\" class=\"{ active: parent.current==num }\" onclick=\"{ parent.page }\">{ num }</li><li class=\"{ disabled: current==total }\" onclick=\"{ next }\">&gt;</li></ul>', function(opts) {\r\n\r\n        this.init = function(o) {\n            this.total = o.total      // total pages\r\n            this.current = 1          // current page\r\n            this.nblocks = o.nblocks  // how many to display\r\n            this.pages = []\r\n            for (i = 1; i <= this.total; i++) this.pages.push(i)\r\n            this.setRange()\r\n        }.bind(this);\n\r\n        this.setRange = function() {\n            var start = this.current <= this.nblocks ?\r\n                    1 : (this.total - this.current) >= this.nblocks ?\r\n                    this.current : this.total - this.nblocks + 1\r\n\r\n            this.range = this.pages.slice(start - 1, start + this.nblocks - 1)\r\n            this.update && this.update()\r\n            this.trigger('pageChange', {\r\n                'page': this.current\r\n            })\r\n        }.bind(this);\n\r\n        this.page = function(e) {\n            self.current = parseInt(e.target.innerHTML) // self because called from loop\r\n            self.setRange()\r\n        }.bind(this);\n\r\n        this.next = function() {\n            if (this.current == this.total) return;\r\n            this.current = Math.min(this.total, this.current + 1)\r\n            this.setRange()\r\n        }.bind(this);\n\r\n        this.prev = function() {\n            if (this.current == 1) return;\r\n            this.current = Math.max(1, this.current - 1)\r\n            this.setRange()\r\n        }.bind(this);\n\r\n        this.init(opts)\r\n\r\n        this.on('setPage', function(p) {\r\n            if (p.page == this.current) return\r\n            this.current = p.page\r\n            this.setRange()\r\n        })\r\n\r\n    \n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./views/eg.tag\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":""}