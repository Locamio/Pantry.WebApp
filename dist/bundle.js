(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define(factory);
	else if(typeof exports === 'object')
		exports["MyLib"] = factory();
	else
		root["MyLib"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _componentsEgTag = __webpack_require__(1);\n\nvar _componentsEgTag2 = _interopRequireDefault(_componentsEgTag);\n\nexports['default'] = {\n  MyComponent: _componentsEgTag2['default']\n};\nmodule.exports = exports['default'];//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQzovZGV2L0Jpei9QYW50cnkuV2ViQXBwL3NyYy9qcy9hcHAuZXM2P2I0YmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxDQUFDOzs7Ozs7OzsyQ0FFVyxDQUFxQjs7OztxQkFFOUI7QUFDYixhQUFXO0NBQ1oiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBNeUNvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudHMvZWcudGFnJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBNeUNvbXBvbmVudFxyXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEM6L2Rldi9CaXovUGFudHJ5LldlYkFwcC9zcmMvanMvYXBwLmVzNlxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("var riot = __webpack_require__(2);\n\nriot.tag('paginator', '<ul><li class=\"{ disabled: current==1 }\" onclick=\"{ prev }\">&lt;</li><li each=\"{ num in range }\" class=\"{ active: parent.current==num }\" onclick=\"{ parent.page }\">{ num }</li><li class=\"{ disabled: current==total }\" onclick=\"{ next }\">&gt;</li></ul>', function(opts) {\r\n\r\n        this.init = function(o) {\n            this.total = o.total      // total pages\r\n            this.current = 1          // current page\r\n            this.nblocks = o.nblocks  // how many to display\r\n            this.pages = []\r\n            for (i = 1; i <= this.total; i++) this.pages.push(i)\r\n            this.setRange()\r\n        }.bind(this);\n\r\n        this.setRange = function() {\n            var start = this.current <= this.nblocks ?\r\n                    1 : (this.total - this.current) >= this.nblocks ?\r\n                    this.current : this.total - this.nblocks + 1\r\n\r\n            this.range = this.pages.slice(start - 1, start + this.nblocks - 1)\r\n            this.update && this.update()\r\n            this.trigger('pageChange', {\r\n                'page': this.current\r\n            })\r\n        }.bind(this);\n\r\n        this.page = function(e) {\n            self.current = parseInt(e.target.innerHTML) // self because called from loop\r\n            self.setRange()\r\n        }.bind(this);\n\r\n        this.next = function() {\n            if (this.current == this.total) return;\r\n            this.current = Math.min(this.total, this.current + 1)\r\n            this.setRange()\r\n        }.bind(this);\n\r\n        this.prev = function() {\n            if (this.current == 1) return;\r\n            this.current = Math.max(1, this.current - 1)\r\n            this.setRange()\r\n        }.bind(this);\n\r\n        this.init(opts)\r\n\r\n        this.on('setPage', function(p) {\r\n            if (p.page == this.current) return\r\n            this.current = p.page\r\n            this.setRange()\r\n        })\r\n\r\n    \n});//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9lZy50YWc/OTQxOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSx1Q0FBdUMsdUJBQXVCLFlBQVksT0FBTyxNQUFNLGdCQUFnQixlQUFlLFVBQVUsOEJBQThCLFlBQVksY0FBYyxHQUFHLE1BQU0saUJBQWlCLDJCQUEyQixZQUFZLE9BQU8sTUFBTTs7QUFFdFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1QsQ0FBQyIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJpb3QgPSByZXF1aXJlKFwicmlvdFwiKTtcblxucmlvdC50YWcoJ3BhZ2luYXRvcicsICc8dWw+PGxpIGNsYXNzPVwieyBkaXNhYmxlZDogY3VycmVudD09MSB9XCIgb25jbGljaz1cInsgcHJldiB9XCI+Jmx0OzwvbGk+PGxpIGVhY2g9XCJ7IG51bSBpbiByYW5nZSB9XCIgY2xhc3M9XCJ7IGFjdGl2ZTogcGFyZW50LmN1cnJlbnQ9PW51bSB9XCIgb25jbGljaz1cInsgcGFyZW50LnBhZ2UgfVwiPnsgbnVtIH08L2xpPjxsaSBjbGFzcz1cInsgZGlzYWJsZWQ6IGN1cnJlbnQ9PXRvdGFsIH1cIiBvbmNsaWNrPVwieyBuZXh0IH1cIj4mZ3Q7PC9saT48L3VsPicsIGZ1bmN0aW9uKG9wdHMpIHtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0ID0gZnVuY3Rpb24obykge1xuICAgICAgICAgICAgdGhpcy50b3RhbCA9IG8udG90YWwgICAgICAvLyB0b3RhbCBwYWdlc1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSAxICAgICAgICAgIC8vIGN1cnJlbnQgcGFnZVxyXG4gICAgICAgICAgICB0aGlzLm5ibG9ja3MgPSBvLm5ibG9ja3MgIC8vIGhvdyBtYW55IHRvIGRpc3BsYXlcclxuICAgICAgICAgICAgdGhpcy5wYWdlcyA9IFtdXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gdGhpcy50b3RhbDsgaSsrKSB0aGlzLnBhZ2VzLnB1c2goaSlcclxuICAgICAgICAgICAgdGhpcy5zZXRSYW5nZSgpXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXHJcbiAgICAgICAgdGhpcy5zZXRSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5jdXJyZW50IDw9IHRoaXMubmJsb2NrcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgMSA6ICh0aGlzLnRvdGFsIC0gdGhpcy5jdXJyZW50KSA+PSB0aGlzLm5ibG9ja3MgP1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA6IHRoaXMudG90YWwgLSB0aGlzLm5ibG9ja3MgKyAxXHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5wYWdlcy5zbGljZShzdGFydCAtIDEsIHN0YXJ0ICsgdGhpcy5uYmxvY2tzIC0gMSlcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUgJiYgdGhpcy51cGRhdGUoKVxyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhZ2VDaGFuZ2UnLCB7XHJcbiAgICAgICAgICAgICAgICAncGFnZSc6IHRoaXMuY3VycmVudFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxyXG4gICAgICAgIHRoaXMucGFnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudCA9IHBhcnNlSW50KGUudGFyZ2V0LmlubmVySFRNTCkgLy8gc2VsZiBiZWNhdXNlIGNhbGxlZCBmcm9tIGxvb3BcclxuICAgICAgICAgICAgc2VsZi5zZXRSYW5nZSgpXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXHJcbiAgICAgICAgdGhpcy5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50ID09IHRoaXMudG90YWwpIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gTWF0aC5taW4odGhpcy50b3RhbCwgdGhpcy5jdXJyZW50ICsgMSlcclxuICAgICAgICAgICAgdGhpcy5zZXRSYW5nZSgpXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXHJcbiAgICAgICAgdGhpcy5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50ID09IDEpIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gTWF0aC5tYXgoMSwgdGhpcy5jdXJyZW50IC0gMSlcclxuICAgICAgICAgICAgdGhpcy5zZXRSYW5nZSgpXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXHJcbiAgICAgICAgdGhpcy5pbml0KG9wdHMpXHJcblxyXG4gICAgICAgIHRoaXMub24oJ3NldFBhZ2UnLCBmdW5jdGlvbihwKSB7XHJcbiAgICAgICAgICAgIGlmIChwLnBhZ2UgPT0gdGhpcy5jdXJyZW50KSByZXR1cm5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gcC5wYWdlXHJcbiAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2UoKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2NvbXBvbmVudHMvZWcudGFnXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Riot v2.1.0, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function(window) {\n  // 'use strict' does not allow us to override the events properties https://github.com/muut/riotjs/blob/dev/lib/tag/update.js#L7-L10\n  // it leads to the following error on firefox \"setting a property that has only a getter\"\n  //'use strict'\n\n\n  var riot = { version: 'v2.1.0', settings: {} }\n\n\nriot.observable = function(el) {\n\n  el = el || {}\n\n  var callbacks = {},\n      _id = 0\n\n  el.on = function(events, fn) {\n    if (typeof fn == 'function') {\n      fn._id = typeof fn._id == 'undefined' ? _id++ : fn._id\n\n      events.replace(/\\S+/g, function(name, pos) {\n        (callbacks[name] = callbacks[name] || []).push(fn)\n        fn.typed = pos > 0\n      })\n    }\n    return el\n  }\n\n  el.off = function(events, fn) {\n    if (events == '*') callbacks = {}\n    else {\n      events.replace(/\\S+/g, function(name) {\n        if (fn) {\n          var arr = callbacks[name]\n          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {\n            if (cb._id == fn._id) { arr.splice(i, 1); i-- }\n          }\n        } else {\n          callbacks[name] = []\n        }\n      })\n    }\n    return el\n  }\n\n  // only single event supported\n  el.one = function(name, fn) {\n    function on() {\n      el.off(name, on)\n      fn.apply(el, arguments)\n    }\n    return el.on(name, on)\n  }\n\n  el.trigger = function(name) {\n    var args = [].slice.call(arguments, 1),\n        fns = callbacks[name] || []\n\n    for (var i = 0, fn; (fn = fns[i]); ++i) {\n      if (!fn.busy) {\n        fn.busy = 1\n        fn.apply(el, fn.typed ? [name].concat(args) : args)\n        if (fns[i] !== fn) { i-- }\n        fn.busy = 0\n      }\n    }\n\n    if (callbacks.all && name != 'all') {\n      el.trigger.apply(el, ['all', name].concat(args))\n    }\n\n    return el\n  }\n\n  return el\n\n}\nriot.mixin = (function() {\n  var registeredMixins = {}\n  return function(name, mixin) {\n    if (!mixin) return registeredMixins[name]\n      else registeredMixins[name] = mixin\n  }\n})()\n\n;(function(riot, evt, window) {\n\n  // browsers only\n  if (!window) return\n\n  var loc = window.location,\n      fns = riot.observable(),\n      win = window,\n      started = false,\n      current\n\n  function hash() {\n    return loc.href.split('#')[1] || ''\n  }\n\n  function parser(path) {\n    return path.split('/')\n  }\n\n  function emit(path) {\n    if (path.type) path = hash()\n\n    if (path != current) {\n      fns.trigger.apply(null, ['H'].concat(parser(path)))\n      current = path\n    }\n  }\n\n  var r = riot.route = function(arg) {\n    // string\n    if (arg[0]) {\n      loc.hash = arg\n      emit(arg)\n\n    // function\n    } else {\n      fns.on('H', arg)\n    }\n  }\n\n  r.exec = function(fn) {\n    fn.apply(null, parser(hash()))\n  }\n\n  r.parser = function(fn) {\n    parser = fn\n  }\n\n  r.stop = function () {\n    if (!started) return\n    win.removeEventListener ? win.removeEventListener(evt, emit, false) : win.detachEvent('on' + evt, emit)\n    fns.off('*')\n    started = false\n  }\n\n  r.start = function () {\n    if (started) return\n    win.addEventListener ? win.addEventListener(evt, emit, false) : win.attachEvent('on' + evt, emit)\n    started = true\n  }\n\n  // autostart the router\n  r.start()\n\n})(riot, 'hashchange', window)\n/*\n\n//// How it works?\n\n\nThree ways:\n\n1. Expressions: tmpl('{ value }', data).\n   Returns the result of evaluated expression as a raw object.\n\n2. Templates: tmpl('Hi { name } { surname }', data).\n   Returns a string with evaluated expressions.\n\n3. Filters: tmpl('{ show: !done, highlight: active }', data).\n   Returns a space separated list of trueish keys (mainly\n   used for setting html classes), e.g. \"show highlight\".\n\n\n// Template examples\n\ntmpl('{ title || \"Untitled\" }', data)\ntmpl('Results are { results ? \"ready\" : \"loading\" }', data)\ntmpl('Today is { new Date() }', data)\ntmpl('{ message.length > 140 && \"Message is too long\" }', data)\ntmpl('This item got { Math.round(rating) } stars', data)\ntmpl('<h1>{ title }</h1>{ body }', data)\n\n\n// Falsy expressions in templates\n\nIn templates (as opposed to single expressions) all falsy values\nexcept zero (undefined/null/false) will default to empty string:\n\ntmpl('{ undefined } - { false } - { null } - { 0 }', {})\n// will return: \" - - - 0\"\n\n*/\n\n\nvar brackets = (function(orig, s, b) {\n  return function(x) {\n\n    // make sure we use the current setting\n    s = riot.settings.brackets || orig\n    if (b != s) b = s.split(' ')\n\n    // if regexp given, rewrite it with current brackets (only if differ from default)\n    return x && x.test\n      ? s == orig\n        ? x : RegExp(x.source\n                      .replace(/\\{/g, b[0].replace(/(?=.)/g, '\\\\'))\n                      .replace(/\\}/g, b[1].replace(/(?=.)/g, '\\\\')),\n                    x.global ? 'g' : '')\n\n      // else, get specific bracket\n      : b[x]\n\n  }\n})('{ }')\n\n\nvar tmpl = (function() {\n\n  var cache = {},\n      reVars = /(['\"\\/]).*?[^\\\\]\\1|\\.\\w*|\\w*:|\\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\\b|function *\\()|([a-z_$]\\w*)/gi\n              // [ 1               ][ 2  ][ 3 ][ 4                                                                                  ][ 5       ]\n              // find variable names:\n              // 1. skip quoted strings and regexps: \"a b\", 'a b', 'a \\'b\\'', /a b/\n              // 2. skip object properties: .name\n              // 3. skip object literals: name:\n              // 4. skip javascript keywords\n              // 5. match var name\n\n  // build a template (or get it from cache), render with data\n  return function(str, data) {\n    return str && (cache[str] = cache[str] || tmpl(str))(data)\n  }\n\n\n  // create a template instance\n\n  function tmpl(s, p) {\n\n    // default template string to {}\n    s = (s || (brackets(0) + brackets(1)))\n\n      // temporarily convert \\{ and \\} to a non-character\n      .replace(brackets(/\\\\{/g), '\\uFFF0')\n      .replace(brackets(/\\\\}/g), '\\uFFF1')\n\n    // split string to expression and non-expresion parts\n    p = split(s, extract(s, brackets(/{/), brackets(/}/)))\n\n    return new Function('d', 'return ' + (\n\n      // is it a single expression or a template? i.e. {x} or <b>{x}</b>\n      !p[0] && !p[2] && !p[3]\n\n        // if expression, evaluate it\n        ? expr(p[1])\n\n        // if template, evaluate all expressions in it\n        : '[' + p.map(function(s, i) {\n\n            // is it an expression or a string (every second part is an expression)\n          return i % 2\n\n              // evaluate the expressions\n              ? expr(s, true)\n\n              // process string parts of the template:\n              : '\"' + s\n\n                  // preserve new lines\n                  .replace(/\\n/g, '\\\\n')\n\n                  // escape quotes\n                  .replace(/\"/g, '\\\\\"')\n\n                + '\"'\n\n        }).join(',') + '].join(\"\")'\n      )\n\n      // bring escaped { and } back\n      .replace(/\\uFFF0/g, brackets(0))\n      .replace(/\\uFFF1/g, brackets(1))\n\n    + ';')\n\n  }\n\n\n  // parse { ... } expression\n\n  function expr(s, n) {\n    s = s\n\n      // convert new lines to spaces\n      .replace(/\\n/g, ' ')\n\n      // trim whitespace, brackets, strip comments\n      .replace(brackets(/^[{ ]+|[ }]+$|\\/\\*.+?\\*\\//g), '')\n\n    // is it an object literal? i.e. { key : value }\n    return /^\\s*[\\w- \"']+ *:/.test(s)\n\n      // if object literal, return trueish keys\n      // e.g.: { show: isOpen(), done: item.done } -> \"show done\"\n      ? '[' +\n\n          // extract key:val pairs, ignoring any nested objects\n          extract(s,\n\n              // name part: name:, \"name\":, 'name':, name :\n              /[\"' ]*[\\w- ]+[\"' ]*:/,\n\n              // expression part: everything upto a comma followed by a name (see above) or end of line\n              /,(?=[\"' ]*[\\w- ]+[\"' ]*:)|}|$/\n              ).map(function(pair) {\n\n                // get key, val parts\n                return pair.replace(/^[ \"']*(.+?)[ \"']*: *(.+?),? *$/, function(_, k, v) {\n\n                  // wrap all conditional parts to ignore errors\n                  return v.replace(/[^&|=!><]+/g, wrap) + '?\"' + k + '\":\"\",'\n\n                })\n\n              }).join('')\n\n        + '].join(\" \").trim()'\n\n      // if js expression, evaluate as javascript\n      : wrap(s, n)\n\n  }\n\n\n  // execute js w/o breaking on errors or undefined vars\n\n  function wrap(s, nonull) {\n    s = s.trim()\n    return !s ? '' : '(function(v){try{v='\n\n        // prefix vars (name => data.name)\n        + (s.replace(reVars, function(s, _, v) { return v ? '(d.'+v+'===undefined?'+(typeof window == 'undefined' ? 'global.' : 'window.')+v+':d.'+v+')' : s })\n\n          // break the expression if its empty (resulting in undefined value)\n          || 'x')\n      + '}catch(e){'\n      + '}finally{return '\n\n        // default to empty string for falsy values except zero\n        + (nonull === true ? '!v&&v!==0?\"\":v' : 'v')\n\n      + '}}).call(d)'\n  }\n\n\n  // split string by an array of substrings\n\n  function split(str, substrings) {\n    var parts = []\n    substrings.map(function(sub, i) {\n\n      // push matched expression and part before it\n      i = str.indexOf(sub)\n      parts.push(str.slice(0, i), sub)\n      str = str.slice(i + sub.length)\n    })\n\n    // push the remaining part\n    return parts.concat(str)\n  }\n\n\n  // match strings between opening and closing regexp, skipping any inner/nested matches\n\n  function extract(str, open, close) {\n\n    var start,\n        level = 0,\n        matches = [],\n        re = new RegExp('('+open.source+')|('+close.source+')', 'g')\n\n    str.replace(re, function(_, open, close, pos) {\n\n      // if outer inner bracket, mark position\n      if(!level && open) start = pos\n\n      // in(de)crease bracket level\n      level += open ? 1 : -1\n\n      // if outer closing bracket, grab the match\n      if(!level && close != null) matches.push(str.slice(start, pos+close.length))\n\n    })\n\n    return matches\n  }\n\n})()\n\n// { key, i in items} -> { key, i, items }\nfunction loopKeys(expr) {\n  var ret = { val: expr },\n      els = expr.split(/\\s+in\\s+/)\n\n  if (els[1]) {\n    ret.val = brackets(0) + els[1]\n    els = els[0].slice(brackets(0).length).trim().split(/,\\s*/)\n    ret.key = els[0]\n    ret.pos = els[1]\n  }\n\n  return ret\n}\n\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n\n/* Beware: heavy stuff */\nfunction _each(dom, parent, expr) {\n\n  remAttr(dom, 'each')\n\n  var template = dom.outerHTML,\n      prev = dom.previousSibling,\n      root = dom.parentNode,\n      rendered = [],\n      tags = [],\n      checksum\n\n  expr = loopKeys(expr)\n\n  function add(pos, item, tag) {\n    rendered.splice(pos, 0, item)\n    tags.splice(pos, 0, tag)\n  }\n\n  // clean template code\n  parent.one('update', function() {\n    root.removeChild(dom)\n\n  }).one('premount', function() {\n    if (root.stub) root = parent.root\n\n  }).on('update', function() {\n\n    var items = tmpl(expr.val, parent)\n    if (!items) return\n\n    // object loop. any changes cause full redraw\n    if (!Array.isArray(items)) {\n      var testsum = JSON.stringify(items)\n\n      if (testsum == checksum) return\n      checksum = testsum\n\n      // clear old items\n      each(tags, function(tag) { tag.unmount() })\n      rendered = []\n      tags = []\n\n      items = Object.keys(items).map(function(key) {\n        return mkitem(expr, key, items[key])\n      })\n\n    }\n\n    // unmount redundant\n    each(rendered, function(item) {\n      if (item instanceof Object) {\n        // skip existing items\n        if (items.indexOf(item) > -1) {\n          return\n        }\n      } else {\n        // find all non-objects\n        var newItems = arrFindEquals(items, item),\n            oldItems = arrFindEquals(rendered, item)\n\n        // if more or equal amount, no need to remove\n        if (newItems.length >= oldItems.length) {\n          return\n        }\n      }\n      var pos = rendered.indexOf(item),\n          tag = tags[pos]\n\n      if (tag) {\n        tag.unmount()\n        rendered.splice(pos, 1)\n        tags.splice(pos, 1)\n        // to let \"each\" know that this item is removed\n        return false\n      }\n\n    })\n\n    // mount new / reorder\n    var prevBase = [].indexOf.call(root.childNodes, prev) + 1\n    each(items, function(item, i) {\n\n      // start index search from position based on the current i\n      var pos = items.indexOf(item, i),\n          oldPos = rendered.indexOf(item, i)\n\n      // if not found, search backwards from current i position\n      pos < 0 && (pos = items.lastIndexOf(item, i))\n      oldPos < 0 && (oldPos = rendered.lastIndexOf(item, i))\n\n      if (!(item instanceof Object)) {\n        // find all non-objects\n        var newItems = arrFindEquals(items, item),\n            oldItems = arrFindEquals(rendered, item)\n\n        // if more, should mount one new\n        if (newItems.length > oldItems.length) {\n          oldPos = -1\n        }\n      }\n\n      // mount new\n      var nodes = root.childNodes\n      if (oldPos < 0) {\n        if (!checksum && expr.key) var _item = mkitem(expr, item, pos)\n\n        var tag = new Tag({ tmpl: template }, {\n          before: nodes[prevBase + pos],\n          parent: parent,\n          root: root,\n          item: _item || item\n        })\n\n        tag.mount()\n\n        add(pos, item, tag)\n        return true\n      }\n\n      // change pos value\n      if (expr.pos && tags[oldPos][expr.pos] != pos) {\n        tags[oldPos].one('update', function(item) {\n          item[expr.pos] = pos\n        })\n        tags[oldPos].update()\n      }\n\n      // reorder\n      if (pos != oldPos) {\n        root.insertBefore(nodes[prevBase + oldPos], nodes[prevBase + (pos > oldPos ? pos + 1 : pos)])\n        return add(pos, rendered.splice(oldPos, 1)[0], tags.splice(oldPos, 1)[0])\n      }\n\n    })\n\n    rendered = items.slice()\n\n  }).one('updated', function() {\n    walk(root, function(dom) {\n      each(dom.attributes, function(attr) {\n        if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom\n      })\n    })\n  })\n\n}\n\n\nfunction parseNamedElements(root, parent, childTags) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = 0\n      if(dom.parentNode && dom.parentNode.isLoop) dom.isLoop = 1\n      if(dom.getAttribute('each')) dom.isLoop = 1\n      // custom child tag\n      var child = getTag(dom)\n\n      if (child && !dom.isLoop) {\n        var tag = new Tag(child, { root: dom, parent: parent }, dom.innerHTML),\n            namedTag = dom.getAttribute('name'),\n            tagName = namedTag && namedTag.indexOf(brackets(0)) < 0 ? namedTag : child.name,\n            ptag = parent,\n            cachedTag\n\n        while(!getTag(ptag.root)) {\n          if(!ptag.parent) break\n          ptag = ptag.parent\n        }\n        // fix for the parent attribute in the looped elements\n        tag.parent = ptag\n\n        cachedTag = ptag.tags[tagName]\n\n        // if there are multiple children tags having the same name\n        if (cachedTag) {\n          // if the parent tags property is not yet an array\n          // create it adding the first cached tag\n          if (!Array.isArray(cachedTag))\n            ptag.tags[tagName] = [cachedTag]\n          // add the new nested tag to the array\n          ptag.tags[tagName].push(tag)\n        } else {\n          ptag.tags[tagName] = tag\n        }\n\n        // empty the child node once we got its template\n        // to avoid that its children get compiled multiple times\n        dom.innerHTML = ''\n        childTags.push(tag)\n      }\n\n      if(!dom.isLoop)\n        each(dom.attributes, function(attr) {\n          if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom\n        })\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (val.indexOf(brackets(0)) >= 0) {\n      var expr = { dom: dom, expr: val }\n      expressions.push(extend(expr, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = dom.getAttribute('each')\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n      opts = inherit(conf.opts) || {},\n      dom = mkdom(impl.tmpl),\n      parent = conf.parent,\n      expressions = [],\n      childTags = [],\n      root = conf.root,\n      item = conf.item,\n      fn = impl.fn,\n      tagName = root.tagName.toLowerCase(),\n      attr = {},\n      loopDom,\n      TAG_ATTRIBUTES = /([\\w\\-]+)\\s?=\\s?['\"]([^'\"]+)[\"']/gim\n\n  if (fn && root._tag) {\n    root._tag.unmount(true)\n  }\n\n  if(impl.attrs) {\n    var attrs = impl.attrs.match(TAG_ATTRIBUTES)\n\n    each(attrs, function(a) {\n      var kv = a.split(/\\s?=\\s?/)\n      root.setAttribute(kv[0], kv[1].replace(/['\"]/g, ''))\n    })\n\n  }\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  this._id = fastAbs(~~(new Date().getTime() * Math.random()))\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    attr[el.name] = el.value\n  })\n\n\n  if (dom.innerHTML && !/select/.test(tagName) && !/tbody/.test(tagName) && !/tr/.test(tagName))\n    // replace all the yield tags with the tag inner html\n    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\n\n  // options\n  function updateOpts() {\n    each(Object.keys(attr), function(name) {\n      opts[name] = tmpl(attr[name], parent || self)\n    })\n  }\n\n  this.update = function(data, init) {\n    extend(self, data, item)\n    updateOpts()\n    self.trigger('update', item)\n    update(expressions, self, item)\n    self.trigger('updated')\n  }\n\n  this.mixin = function() {\n    each(arguments, function(mix) {\n      mix = 'string' == typeof mix ? riot.mixin(mix) : mix\n      each(Object.keys(mix), function(key) {\n        // bind methods to self\n        if ('init' != key)\n          self[key] = 'function' == typeof mix[key] ? mix[key].bind(self) : mix[key]\n      })\n      // init method will be called automatically\n      if (mix.init) mix.init.bind(self)()\n    })\n  }\n\n  this.mount = function() {\n\n    updateOpts()\n\n    // initialiation\n    fn && fn.call(self, opts)\n\n    toggle(true)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    if (!self.parent) self.update()\n\n    // internal use only, fixes #403\n    self.trigger('premount')\n\n    if (fn) {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n\n    } else {\n      loopDom = dom.firstChild\n      root.insertBefore(loopDom, conf.before || null) // null needed for IE8\n    }\n\n    if (root.stub) self.root = root = parent.root\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent) self.trigger('mount')\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() { self.trigger('mount') })\n  }\n\n\n  this.unmount = function(keepRootTag) {\n    var el = fn ? root : loopDom,\n        p = el.parentNode\n\n    if (p) {\n\n      if (parent) {\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (Array.isArray(parent.tags[tagName])) {\n          each(parent.tags[tagName], function(tag, i) {\n            if (tag._id == self._id)\n              parent.tags[tagName].splice(i, 1)\n          })\n        } else\n          // otherwise just delete the tag instance\n          parent.tags[tagName] = undefined\n      } else {\n        while (el.firstChild) el.removeChild(el.firstChild)\n      }\n\n      if (!keepRootTag)\n        p.removeChild(el)\n\n    }\n\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    // somehow ie8 does not like `delete root._tag`\n    root._tag = null\n\n  }\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (parent) {\n      var evt = isMount ? 'on' : 'off'\n      parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n    }\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n\n}\n\nfunction setEventHandler(name, handler, dom, tag, item) {\n\n  dom[name] = function(e) {\n\n    // cross browser event fix\n    e = e || window.event\n    e.which = e.which || e.charCode || e.keyCode\n    e.target = e.target || e.srcElement\n    e.currentTarget = dom\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      e.preventDefault && e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      var el = item ? tag.parent : tag\n      el.update()\n    }\n\n  }\n\n}\n\n// used by if- attribute\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\n// item = currently looped item\nfunction update(expressions, tag, item) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n        attrName = expr.attr,\n        value = tmpl(expr.expr, tag),\n        parent = expr.dom.parentNode\n\n    if (value == null) value = ''\n\n    // leave out riot- prefixes from strings inside textarea\n    if (parent && parent.tagName == 'TEXTAREA') value = value.replace(/riot-/g, '')\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attrName) return dom.nodeValue = value.toString()\n\n    // remove original attribute\n    remAttr(dom, attrName)\n\n    // event handler\n    if (typeof value == 'function') {\n      setEventHandler(attrName, value, dom, tag, item)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub\n\n      // add to DOM\n      if (value) {\n        stub && insertTo(stub.parentNode, stub, dom)\n\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        insertTo(dom.parentNode, dom, stub)\n      }\n\n    // show / hide\n    } else if (/^(show|hide)$/.test(attrName)) {\n      if (attrName == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // field value\n    } else if (attrName == 'value') {\n      dom.value = value\n\n    // <img src=\"{ expr }\">\n    } else if (attrName.slice(0, 5) == 'riot-') {\n      attrName = attrName.slice(5)\n      value ? dom.setAttribute(attrName, value) : remAttr(dom, attrName)\n\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value\n        if (!value) return\n        value = attrName\n      }\n\n      if (typeof value != 'object') dom.setAttribute(attrName, value)\n\n    }\n\n  })\n\n}\n\nfunction each(els, fn) {\n  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n    el = els[i]\n    // return false -> remove current item during loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\nfunction fastAbs(nr) {\n  return (nr ^ (nr >> 31)) - (nr >> 31)\n}\n\n// max 2 from objects allowed\nfunction extend(obj, from, from2) {\n  from && each(Object.keys(from), function(key) {\n    obj[key] = from[key]\n  })\n  return from2 ? extend(obj, from2) : obj\n}\n\nfunction checkIE() {\n  if (window) {\n    var ua = navigator.userAgent\n    var msie = ua.indexOf('MSIE ')\n    if (msie > 0) {\n      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n    }\n    else {\n      return 0\n    }\n  }\n}\n\nfunction optionInnerHTML(el, html) {\n  var opt = document.createElement('option'),\n      valRegx = /value=[\\\"'](.+?)[\\\"']/,\n      selRegx = /selected=[\\\"'](.+?)[\\\"']/,\n      valuesMatch = html.match(valRegx),\n      selectedMatch = html.match(selRegx)\n\n  opt.innerHTML = html\n\n  if (valuesMatch) {\n    opt.value = valuesMatch[1]\n  }\n\n  if (selectedMatch) {\n    opt.setAttribute('riot-selected', selectedMatch[1])\n  }\n\n  el.appendChild(opt)\n}\n\nfunction tbodyInnerHTML(el, html, tagName) {\n  var div = document.createElement('div')\n  div.innerHTML = '<table>' + html + '</table>'\n\n  if (/td|th/.test(tagName)) {\n    el.appendChild(div.firstChild.firstChild.firstChild.firstChild)\n  } else {\n    el.appendChild(div.firstChild.firstChild.firstChild)\n  }\n}\n\nfunction mkdom(template) {\n  var tagName = template.trim().slice(1, 3).toLowerCase(),\n      rootTag = /td|th/.test(tagName) ? 'tr' : tagName == 'tr' ? 'tbody' : 'div',\n      el = mkEl(rootTag)\n\n  el.stub = true\n\n  if (tagName === 'op' && ieVersion && ieVersion < 10) {\n    optionInnerHTML(el, template)\n  } else if ((rootTag === 'tbody' || rootTag === 'tr') && ieVersion && ieVersion < 10) {\n    tbodyInnerHTML(el, template, tagName)\n  } else\n    el.innerHTML = template\n\n  return el\n}\n\nfunction walk(dom, fn) {\n  if (dom) {\n    if (fn(dom) === false) walk(dom.nextSibling, fn)\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\nfunction replaceYield (tmpl, innerHTML) {\n  return tmpl.replace(/<(yield)\\/?>(<\\/\\1>)?/gim, innerHTML || '')\n}\n\nfunction $$(selector, ctx) {\n  ctx = ctx || document\n  return ctx.querySelectorAll(selector)\n}\n\nfunction arrDiff(arr1, arr2) {\n  return arr1.filter(function(el) {\n    return arr2.indexOf(el) < 0\n  })\n}\n\nfunction arrFindEquals(arr, el) {\n  return arr.filter(function (_el) {\n    return _el === el\n  })\n}\n\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n/**\n *\n * Hacks needed for the old internet explorer versions [lower than IE10]\n *\n */\n\nvar ieVersion = checkIE()\n\nfunction checkIE() {\n  if (window) {\n    var ua = navigator.userAgent\n    var msie = ua.indexOf('MSIE ')\n    if (msie > 0) {\n      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n    }\n    else {\n      return 0\n    }\n  }\n}\n\nfunction tbodyInnerHTML(el, html, tagName) {\n  var div = mkEl('div'),\n      loops = /td|th/.test(tagName) ? 3 : 2,\n      child\n\n  div.innerHTML = '<table>' + html + '</table>'\n  child = div.firstChild\n\n  while(loops--) {\n    child = child.firstChild\n  }\n\n  el.appendChild(child)\n\n}\n\nfunction optionInnerHTML(el, html) {\n  var opt = mkEl('option'),\n      valRegx = /value=[\\\"'](.+?)[\\\"']/,\n      selRegx = /selected=[\\\"'](.+?)[\\\"']/,\n      valuesMatch = html.match(valRegx),\n      selectedMatch = html.match(selRegx)\n\n  opt.innerHTML = html\n\n  if (valuesMatch) {\n    opt.value = valuesMatch[1]\n  }\n\n  if (selectedMatch) {\n    opt.setAttribute('riot-selected', selectedMatch[1])\n  }\n\n  el.appendChild(opt)\n}\n\n/*\n Virtual dom is an array of custom tags on the document.\n Updates and unmounts propagate downwards from parent to children.\n*/\n\nvar virtualDom = [],\n    tagImpl = {},\n    styleNode\n\n\nfunction getTag(dom) {\n  return tagImpl[dom.getAttribute('riot-tag') || dom.tagName.toLowerCase()]\n}\n\nfunction injectStyle(css) {\n\n  styleNode = styleNode || mkEl('style')\n\n  if (!document.head) return\n\n  if(styleNode.styleSheet)\n    styleNode.styleSheet.cssText += css\n  else\n    styleNode.innerHTML += css\n\n  if (!styleNode._rendered)\n    if (styleNode.styleSheet)\n      document.body.appendChild(styleNode)\n    else\n      document.head.appendChild(styleNode)\n\n  styleNode._rendered = true\n\n}\n\nfunction mountTo(root, tagName, opts) {\n  var tag = tagImpl[tagName],\n      innerHTML = root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    virtualDom.push(tag)\n    return tag.on('unmount', function() {\n      virtualDom.splice(virtualDom.indexOf(tag), 1)\n    })\n  }\n\n}\n\nriot.tag = function(name, html, css, attrs, fn) {\n  if (typeof attrs == 'function') {\n    fn = attrs\n    if(/^[\\w\\-]+\\s?=/.test(css)) {attrs = css; css = ''} else attrs = ''\n  }\n  if (typeof css == 'function') fn = css\n  else if (css) injectStyle(css)\n  tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\nriot.mount = function(selector, tagName, opts) {\n\n  var el,\n      selctAllTags = function() {\n        var keys = Object.keys(tagImpl)\n        var list = keys.join(', ')\n        each(keys, function(t) {\n          list += ', *[riot-tag=\"'+ t.trim() + '\"]'\n        })\n        return list\n      },\n      allTags,\n      tags = []\n\n  if (typeof tagName == 'object') { opts = tagName; tagName = 0 }\n\n  // crawl the DOM to find the tag\n  if(typeof selector == 'string') {\n    if (selector == '*') {\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selctAllTags()\n    } else {\n      selector.split(',').map(function(t) {\n        selector += ', *[riot-tag=\"'+ t.trim() + '\"]'\n      })\n\n    }\n    // or just the ones named like the selector\n    el = $$(selector)\n  }\n  // probably you have passed already a tag or a NodeList\n  else\n    el = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName == '*') {\n    // get all custom tags\n    tagName = allTags || selctAllTags()\n    // if the root el it's just a single tag\n    if (el.tagName) {\n      el = $$(tagName, el)\n    } else {\n      var nodeList = []\n      // select all the children for all the different root elements\n      each(el, function(tag) {\n        nodeList = $$(tagName, tag)\n      })\n      el = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  function push(root) {\n    if(tagName && !root.getAttribute('riot-tag')) root.setAttribute('riot-tag', tagName)\n\n    var name = tagName || root.getAttribute('riot-tag') || root.tagName.toLowerCase(),\n        tag = mountTo(root, name, opts)\n\n    if (tag) tags.push(tag)\n  }\n\n  // DOM node\n  if (el.tagName)\n    push(selector)\n  // selector or NodeList\n  else\n    each(el, push)\n\n  return tags\n\n}\n\n// update everything\nriot.update = function() {\n  return each(virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n// @deprecated\nriot.mountTo = riot.mount\n\n\n  // share methods for other riot parts, e.g. compiler\n  riot.util = { brackets: brackets, tmpl: tmpl }\n\n  // support CommonJS, AMD & browser\n  if (true)\n    module.exports = riot\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return riot })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : undefined);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Jpb3QvcmlvdC5qcz81MGU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBLGNBQWMsZ0NBQWdDOzs7QUFHOUM7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQSx1QkFBdUIsUUFBUTtBQUMvQjs7QUFFQSx3QkFBd0IsT0FBTyxFQUFFLFVBQVU7QUFD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YztBQUNyQztBQUNBOztBQUVBLENBQUMiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIFJpb3QgdjIuMS4wLCBAbGljZW5zZSBNSVQsIChjKSAyMDE1IE11dXQgSW5jLiArIGNvbnRyaWJ1dG9ycyAqL1xuXG47KGZ1bmN0aW9uKHdpbmRvdykge1xuICAvLyAndXNlIHN0cmljdCcgZG9lcyBub3QgYWxsb3cgdXMgdG8gb3ZlcnJpZGUgdGhlIGV2ZW50cyBwcm9wZXJ0aWVzIGh0dHBzOi8vZ2l0aHViLmNvbS9tdXV0L3Jpb3Rqcy9ibG9iL2Rldi9saWIvdGFnL3VwZGF0ZS5qcyNMNy1MMTBcbiAgLy8gaXQgbGVhZHMgdG8gdGhlIGZvbGxvd2luZyBlcnJvciBvbiBmaXJlZm94IFwic2V0dGluZyBhIHByb3BlcnR5IHRoYXQgaGFzIG9ubHkgYSBnZXR0ZXJcIlxuICAvLyd1c2Ugc3RyaWN0J1xuXG5cbiAgdmFyIHJpb3QgPSB7IHZlcnNpb246ICd2Mi4xLjAnLCBzZXR0aW5nczoge30gfVxuXG5cbnJpb3Qub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uKGVsKSB7XG5cbiAgZWwgPSBlbCB8fCB7fVxuXG4gIHZhciBjYWxsYmFja3MgPSB7fSxcbiAgICAgIF9pZCA9IDBcblxuICBlbC5vbiA9IGZ1bmN0aW9uKGV2ZW50cywgZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZuLl9pZCA9IHR5cGVvZiBmbi5faWQgPT0gJ3VuZGVmaW5lZCcgPyBfaWQrKyA6IGZuLl9pZFxuXG4gICAgICBldmVudHMucmVwbGFjZSgvXFxTKy9nLCBmdW5jdGlvbihuYW1lLCBwb3MpIHtcbiAgICAgICAgKGNhbGxiYWNrc1tuYW1lXSA9IGNhbGxiYWNrc1tuYW1lXSB8fCBbXSkucHVzaChmbilcbiAgICAgICAgZm4udHlwZWQgPSBwb3MgPiAwXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIGVsLm9mZiA9IGZ1bmN0aW9uKGV2ZW50cywgZm4pIHtcbiAgICBpZiAoZXZlbnRzID09ICcqJykgY2FsbGJhY2tzID0ge31cbiAgICBlbHNlIHtcbiAgICAgIGV2ZW50cy5yZXBsYWNlKC9cXFMrL2csIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgdmFyIGFyciA9IGNhbGxiYWNrc1tuYW1lXVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjYjsgKGNiID0gYXJyICYmIGFycltpXSk7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNiLl9pZCA9PSBmbi5faWQpIHsgYXJyLnNwbGljZShpLCAxKTsgaS0tIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2tzW25hbWVdID0gW11cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICAvLyBvbmx5IHNpbmdsZSBldmVudCBzdXBwb3J0ZWRcbiAgZWwub25lID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgIGVsLm9mZihuYW1lLCBvbilcbiAgICAgIGZuLmFwcGx5KGVsLCBhcmd1bWVudHMpXG4gICAgfVxuICAgIHJldHVybiBlbC5vbihuYW1lLCBvbilcbiAgfVxuXG4gIGVsLnRyaWdnZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgIGZucyA9IGNhbGxiYWNrc1tuYW1lXSB8fCBbXVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGZuOyAoZm4gPSBmbnNbaV0pOyArK2kpIHtcbiAgICAgIGlmICghZm4uYnVzeSkge1xuICAgICAgICBmbi5idXN5ID0gMVxuICAgICAgICBmbi5hcHBseShlbCwgZm4udHlwZWQgPyBbbmFtZV0uY29uY2F0KGFyZ3MpIDogYXJncylcbiAgICAgICAgaWYgKGZuc1tpXSAhPT0gZm4pIHsgaS0tIH1cbiAgICAgICAgZm4uYnVzeSA9IDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2tzLmFsbCAmJiBuYW1lICE9ICdhbGwnKSB7XG4gICAgICBlbC50cmlnZ2VyLmFwcGx5KGVsLCBbJ2FsbCcsIG5hbWVdLmNvbmNhdChhcmdzKSlcbiAgICB9XG5cbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIHJldHVybiBlbFxuXG59XG5yaW90Lm1peGluID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgcmVnaXN0ZXJlZE1peGlucyA9IHt9XG4gIHJldHVybiBmdW5jdGlvbihuYW1lLCBtaXhpbikge1xuICAgIGlmICghbWl4aW4pIHJldHVybiByZWdpc3RlcmVkTWl4aW5zW25hbWVdXG4gICAgICBlbHNlIHJlZ2lzdGVyZWRNaXhpbnNbbmFtZV0gPSBtaXhpblxuICB9XG59KSgpXG5cbjsoZnVuY3Rpb24ocmlvdCwgZXZ0LCB3aW5kb3cpIHtcblxuICAvLyBicm93c2VycyBvbmx5XG4gIGlmICghd2luZG93KSByZXR1cm5cblxuICB2YXIgbG9jID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgZm5zID0gcmlvdC5vYnNlcnZhYmxlKCksXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBzdGFydGVkID0gZmFsc2UsXG4gICAgICBjdXJyZW50XG5cbiAgZnVuY3Rpb24gaGFzaCgpIHtcbiAgICByZXR1cm4gbG9jLmhyZWYuc3BsaXQoJyMnKVsxXSB8fCAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VyKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5zcGxpdCgnLycpXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0KHBhdGgpIHtcbiAgICBpZiAocGF0aC50eXBlKSBwYXRoID0gaGFzaCgpXG5cbiAgICBpZiAocGF0aCAhPSBjdXJyZW50KSB7XG4gICAgICBmbnMudHJpZ2dlci5hcHBseShudWxsLCBbJ0gnXS5jb25jYXQocGFyc2VyKHBhdGgpKSlcbiAgICAgIGN1cnJlbnQgPSBwYXRoXG4gICAgfVxuICB9XG5cbiAgdmFyIHIgPSByaW90LnJvdXRlID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgLy8gc3RyaW5nXG4gICAgaWYgKGFyZ1swXSkge1xuICAgICAgbG9jLmhhc2ggPSBhcmdcbiAgICAgIGVtaXQoYXJnKVxuXG4gICAgLy8gZnVuY3Rpb25cbiAgICB9IGVsc2Uge1xuICAgICAgZm5zLm9uKCdIJywgYXJnKVxuICAgIH1cbiAgfVxuXG4gIHIuZXhlYyA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgZm4uYXBwbHkobnVsbCwgcGFyc2VyKGhhc2goKSkpXG4gIH1cblxuICByLnBhcnNlciA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgcGFyc2VyID0gZm5cbiAgfVxuXG4gIHIuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXN0YXJ0ZWQpIHJldHVyblxuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyID8gd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBlbWl0LCBmYWxzZSkgOiB3aW4uZGV0YWNoRXZlbnQoJ29uJyArIGV2dCwgZW1pdClcbiAgICBmbnMub2ZmKCcqJylcbiAgICBzdGFydGVkID0gZmFsc2VcbiAgfVxuXG4gIHIuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0YXJ0ZWQpIHJldHVyblxuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyID8gd2luLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBlbWl0LCBmYWxzZSkgOiB3aW4uYXR0YWNoRXZlbnQoJ29uJyArIGV2dCwgZW1pdClcbiAgICBzdGFydGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gYXV0b3N0YXJ0IHRoZSByb3V0ZXJcbiAgci5zdGFydCgpXG5cbn0pKHJpb3QsICdoYXNoY2hhbmdlJywgd2luZG93KVxuLypcblxuLy8vLyBIb3cgaXQgd29ya3M/XG5cblxuVGhyZWUgd2F5czpcblxuMS4gRXhwcmVzc2lvbnM6IHRtcGwoJ3sgdmFsdWUgfScsIGRhdGEpLlxuICAgUmV0dXJucyB0aGUgcmVzdWx0IG9mIGV2YWx1YXRlZCBleHByZXNzaW9uIGFzIGEgcmF3IG9iamVjdC5cblxuMi4gVGVtcGxhdGVzOiB0bXBsKCdIaSB7IG5hbWUgfSB7IHN1cm5hbWUgfScsIGRhdGEpLlxuICAgUmV0dXJucyBhIHN0cmluZyB3aXRoIGV2YWx1YXRlZCBleHByZXNzaW9ucy5cblxuMy4gRmlsdGVyczogdG1wbCgneyBzaG93OiAhZG9uZSwgaGlnaGxpZ2h0OiBhY3RpdmUgfScsIGRhdGEpLlxuICAgUmV0dXJucyBhIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIHRydWVpc2gga2V5cyAobWFpbmx5XG4gICB1c2VkIGZvciBzZXR0aW5nIGh0bWwgY2xhc3NlcyksIGUuZy4gXCJzaG93IGhpZ2hsaWdodFwiLlxuXG5cbi8vIFRlbXBsYXRlIGV4YW1wbGVzXG5cbnRtcGwoJ3sgdGl0bGUgfHwgXCJVbnRpdGxlZFwiIH0nLCBkYXRhKVxudG1wbCgnUmVzdWx0cyBhcmUgeyByZXN1bHRzID8gXCJyZWFkeVwiIDogXCJsb2FkaW5nXCIgfScsIGRhdGEpXG50bXBsKCdUb2RheSBpcyB7IG5ldyBEYXRlKCkgfScsIGRhdGEpXG50bXBsKCd7IG1lc3NhZ2UubGVuZ3RoID4gMTQwICYmIFwiTWVzc2FnZSBpcyB0b28gbG9uZ1wiIH0nLCBkYXRhKVxudG1wbCgnVGhpcyBpdGVtIGdvdCB7IE1hdGgucm91bmQocmF0aW5nKSB9IHN0YXJzJywgZGF0YSlcbnRtcGwoJzxoMT57IHRpdGxlIH08L2gxPnsgYm9keSB9JywgZGF0YSlcblxuXG4vLyBGYWxzeSBleHByZXNzaW9ucyBpbiB0ZW1wbGF0ZXNcblxuSW4gdGVtcGxhdGVzIChhcyBvcHBvc2VkIHRvIHNpbmdsZSBleHByZXNzaW9ucykgYWxsIGZhbHN5IHZhbHVlc1xuZXhjZXB0IHplcm8gKHVuZGVmaW5lZC9udWxsL2ZhbHNlKSB3aWxsIGRlZmF1bHQgdG8gZW1wdHkgc3RyaW5nOlxuXG50bXBsKCd7IHVuZGVmaW5lZCB9IC0geyBmYWxzZSB9IC0geyBudWxsIH0gLSB7IDAgfScsIHt9KVxuLy8gd2lsbCByZXR1cm46IFwiIC0gLSAtIDBcIlxuXG4qL1xuXG5cbnZhciBicmFja2V0cyA9IChmdW5jdGlvbihvcmlnLCBzLCBiKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UgdXNlIHRoZSBjdXJyZW50IHNldHRpbmdcbiAgICBzID0gcmlvdC5zZXR0aW5ncy5icmFja2V0cyB8fCBvcmlnXG4gICAgaWYgKGIgIT0gcykgYiA9IHMuc3BsaXQoJyAnKVxuXG4gICAgLy8gaWYgcmVnZXhwIGdpdmVuLCByZXdyaXRlIGl0IHdpdGggY3VycmVudCBicmFja2V0cyAob25seSBpZiBkaWZmZXIgZnJvbSBkZWZhdWx0KVxuICAgIHJldHVybiB4ICYmIHgudGVzdFxuICAgICAgPyBzID09IG9yaWdcbiAgICAgICAgPyB4IDogUmVnRXhwKHguc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcey9nLCBiWzBdLnJlcGxhY2UoLyg/PS4pL2csICdcXFxcJykpXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcfS9nLCBiWzFdLnJlcGxhY2UoLyg/PS4pL2csICdcXFxcJykpLFxuICAgICAgICAgICAgICAgICAgICB4Lmdsb2JhbCA/ICdnJyA6ICcnKVxuXG4gICAgICAvLyBlbHNlLCBnZXQgc3BlY2lmaWMgYnJhY2tldFxuICAgICAgOiBiW3hdXG5cbiAgfVxufSkoJ3sgfScpXG5cblxudmFyIHRtcGwgPSAoZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGNhY2hlID0ge30sXG4gICAgICByZVZhcnMgPSAvKFsnXCJcXC9dKS4qP1teXFxcXF1cXDF8XFwuXFx3KnxcXHcqOnxcXGIoPzooPzpuZXd8dHlwZW9mfGlufGluc3RhbmNlb2YpIHwoPzp0aGlzfHRydWV8ZmFsc2V8bnVsbHx1bmRlZmluZWQpXFxifGZ1bmN0aW9uICpcXCgpfChbYS16XyRdXFx3KikvZ2lcbiAgICAgICAgICAgICAgLy8gWyAxICAgICAgICAgICAgICAgXVsgMiAgXVsgMyBdWyA0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1bIDUgICAgICAgXVxuICAgICAgICAgICAgICAvLyBmaW5kIHZhcmlhYmxlIG5hbWVzOlxuICAgICAgICAgICAgICAvLyAxLiBza2lwIHF1b3RlZCBzdHJpbmdzIGFuZCByZWdleHBzOiBcImEgYlwiLCAnYSBiJywgJ2EgXFwnYlxcJycsIC9hIGIvXG4gICAgICAgICAgICAgIC8vIDIuIHNraXAgb2JqZWN0IHByb3BlcnRpZXM6IC5uYW1lXG4gICAgICAgICAgICAgIC8vIDMuIHNraXAgb2JqZWN0IGxpdGVyYWxzOiBuYW1lOlxuICAgICAgICAgICAgICAvLyA0LiBza2lwIGphdmFzY3JpcHQga2V5d29yZHNcbiAgICAgICAgICAgICAgLy8gNS4gbWF0Y2ggdmFyIG5hbWVcblxuICAvLyBidWlsZCBhIHRlbXBsYXRlIChvciBnZXQgaXQgZnJvbSBjYWNoZSksIHJlbmRlciB3aXRoIGRhdGFcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgZGF0YSkge1xuICAgIHJldHVybiBzdHIgJiYgKGNhY2hlW3N0cl0gPSBjYWNoZVtzdHJdIHx8IHRtcGwoc3RyKSkoZGF0YSlcbiAgfVxuXG5cbiAgLy8gY3JlYXRlIGEgdGVtcGxhdGUgaW5zdGFuY2VcblxuICBmdW5jdGlvbiB0bXBsKHMsIHApIHtcblxuICAgIC8vIGRlZmF1bHQgdGVtcGxhdGUgc3RyaW5nIHRvIHt9XG4gICAgcyA9IChzIHx8IChicmFja2V0cygwKSArIGJyYWNrZXRzKDEpKSlcblxuICAgICAgLy8gdGVtcG9yYXJpbHkgY29udmVydCBcXHsgYW5kIFxcfSB0byBhIG5vbi1jaGFyYWN0ZXJcbiAgICAgIC5yZXBsYWNlKGJyYWNrZXRzKC9cXFxcey9nKSwgJ1xcdUZGRjAnKVxuICAgICAgLnJlcGxhY2UoYnJhY2tldHMoL1xcXFx9L2cpLCAnXFx1RkZGMScpXG5cbiAgICAvLyBzcGxpdCBzdHJpbmcgdG8gZXhwcmVzc2lvbiBhbmQgbm9uLWV4cHJlc2lvbiBwYXJ0c1xuICAgIHAgPSBzcGxpdChzLCBleHRyYWN0KHMsIGJyYWNrZXRzKC97LyksIGJyYWNrZXRzKC99LykpKVxuXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignZCcsICdyZXR1cm4gJyArIChcblxuICAgICAgLy8gaXMgaXQgYSBzaW5nbGUgZXhwcmVzc2lvbiBvciBhIHRlbXBsYXRlPyBpLmUuIHt4fSBvciA8Yj57eH08L2I+XG4gICAgICAhcFswXSAmJiAhcFsyXSAmJiAhcFszXVxuXG4gICAgICAgIC8vIGlmIGV4cHJlc3Npb24sIGV2YWx1YXRlIGl0XG4gICAgICAgID8gZXhwcihwWzFdKVxuXG4gICAgICAgIC8vIGlmIHRlbXBsYXRlLCBldmFsdWF0ZSBhbGwgZXhwcmVzc2lvbnMgaW4gaXRcbiAgICAgICAgOiAnWycgKyBwLm1hcChmdW5jdGlvbihzLCBpKSB7XG5cbiAgICAgICAgICAgIC8vIGlzIGl0IGFuIGV4cHJlc3Npb24gb3IgYSBzdHJpbmcgKGV2ZXJ5IHNlY29uZCBwYXJ0IGlzIGFuIGV4cHJlc3Npb24pXG4gICAgICAgICAgcmV0dXJuIGkgJSAyXG5cbiAgICAgICAgICAgICAgLy8gZXZhbHVhdGUgdGhlIGV4cHJlc3Npb25zXG4gICAgICAgICAgICAgID8gZXhwcihzLCB0cnVlKVxuXG4gICAgICAgICAgICAgIC8vIHByb2Nlc3Mgc3RyaW5nIHBhcnRzIG9mIHRoZSB0ZW1wbGF0ZTpcbiAgICAgICAgICAgICAgOiAnXCInICsgc1xuXG4gICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSBuZXcgbGluZXNcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcblxuICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHF1b3Rlc1xuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKVxuXG4gICAgICAgICAgICAgICAgKyAnXCInXG5cbiAgICAgICAgfSkuam9pbignLCcpICsgJ10uam9pbihcIlwiKSdcbiAgICAgIClcblxuICAgICAgLy8gYnJpbmcgZXNjYXBlZCB7IGFuZCB9IGJhY2tcbiAgICAgIC5yZXBsYWNlKC9cXHVGRkYwL2csIGJyYWNrZXRzKDApKVxuICAgICAgLnJlcGxhY2UoL1xcdUZGRjEvZywgYnJhY2tldHMoMSkpXG5cbiAgICArICc7JylcblxuICB9XG5cblxuICAvLyBwYXJzZSB7IC4uLiB9IGV4cHJlc3Npb25cblxuICBmdW5jdGlvbiBleHByKHMsIG4pIHtcbiAgICBzID0gc1xuXG4gICAgICAvLyBjb252ZXJ0IG5ldyBsaW5lcyB0byBzcGFjZXNcbiAgICAgIC5yZXBsYWNlKC9cXG4vZywgJyAnKVxuXG4gICAgICAvLyB0cmltIHdoaXRlc3BhY2UsIGJyYWNrZXRzLCBzdHJpcCBjb21tZW50c1xuICAgICAgLnJlcGxhY2UoYnJhY2tldHMoL15beyBdK3xbIH1dKyR8XFwvXFwqLis/XFwqXFwvL2cpLCAnJylcblxuICAgIC8vIGlzIGl0IGFuIG9iamVjdCBsaXRlcmFsPyBpLmUuIHsga2V5IDogdmFsdWUgfVxuICAgIHJldHVybiAvXlxccypbXFx3LSBcIiddKyAqOi8udGVzdChzKVxuXG4gICAgICAvLyBpZiBvYmplY3QgbGl0ZXJhbCwgcmV0dXJuIHRydWVpc2gga2V5c1xuICAgICAgLy8gZS5nLjogeyBzaG93OiBpc09wZW4oKSwgZG9uZTogaXRlbS5kb25lIH0gLT4gXCJzaG93IGRvbmVcIlxuICAgICAgPyAnWycgK1xuXG4gICAgICAgICAgLy8gZXh0cmFjdCBrZXk6dmFsIHBhaXJzLCBpZ25vcmluZyBhbnkgbmVzdGVkIG9iamVjdHNcbiAgICAgICAgICBleHRyYWN0KHMsXG5cbiAgICAgICAgICAgICAgLy8gbmFtZSBwYXJ0OiBuYW1lOiwgXCJuYW1lXCI6LCAnbmFtZSc6LCBuYW1lIDpcbiAgICAgICAgICAgICAgL1tcIicgXSpbXFx3LSBdK1tcIicgXSo6LyxcblxuICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIHBhcnQ6IGV2ZXJ5dGhpbmcgdXB0byBhIGNvbW1hIGZvbGxvd2VkIGJ5IGEgbmFtZSAoc2VlIGFib3ZlKSBvciBlbmQgb2YgbGluZVxuICAgICAgICAgICAgICAvLCg/PVtcIicgXSpbXFx3LSBdK1tcIicgXSo6KXx9fCQvXG4gICAgICAgICAgICAgICkubWFwKGZ1bmN0aW9uKHBhaXIpIHtcblxuICAgICAgICAgICAgICAgIC8vIGdldCBrZXksIHZhbCBwYXJ0c1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWlyLnJlcGxhY2UoL15bIFwiJ10qKC4rPylbIFwiJ10qOiAqKC4rPyksPyAqJC8sIGZ1bmN0aW9uKF8sIGssIHYpIHtcblxuICAgICAgICAgICAgICAgICAgLy8gd3JhcCBhbGwgY29uZGl0aW9uYWwgcGFydHMgdG8gaWdub3JlIGVycm9yc1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHYucmVwbGFjZSgvW14mfD0hPjxdKy9nLCB3cmFwKSArICc/XCInICsgayArICdcIjpcIlwiLCdcblxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgfSkuam9pbignJylcblxuICAgICAgICArICddLmpvaW4oXCIgXCIpLnRyaW0oKSdcblxuICAgICAgLy8gaWYganMgZXhwcmVzc2lvbiwgZXZhbHVhdGUgYXMgamF2YXNjcmlwdFxuICAgICAgOiB3cmFwKHMsIG4pXG5cbiAgfVxuXG5cbiAgLy8gZXhlY3V0ZSBqcyB3L28gYnJlYWtpbmcgb24gZXJyb3JzIG9yIHVuZGVmaW5lZCB2YXJzXG5cbiAgZnVuY3Rpb24gd3JhcChzLCBub251bGwpIHtcbiAgICBzID0gcy50cmltKClcbiAgICByZXR1cm4gIXMgPyAnJyA6ICcoZnVuY3Rpb24odil7dHJ5e3Y9J1xuXG4gICAgICAgIC8vIHByZWZpeCB2YXJzIChuYW1lID0+IGRhdGEubmFtZSlcbiAgICAgICAgKyAocy5yZXBsYWNlKHJlVmFycywgZnVuY3Rpb24ocywgXywgdikgeyByZXR1cm4gdiA/ICcoZC4nK3YrJz09PXVuZGVmaW5lZD8nKyh0eXBlb2Ygd2luZG93ID09ICd1bmRlZmluZWQnID8gJ2dsb2JhbC4nIDogJ3dpbmRvdy4nKSt2Kyc6ZC4nK3YrJyknIDogcyB9KVxuXG4gICAgICAgICAgLy8gYnJlYWsgdGhlIGV4cHJlc3Npb24gaWYgaXRzIGVtcHR5IChyZXN1bHRpbmcgaW4gdW5kZWZpbmVkIHZhbHVlKVxuICAgICAgICAgIHx8ICd4JylcbiAgICAgICsgJ31jYXRjaChlKXsnXG4gICAgICArICd9ZmluYWxseXtyZXR1cm4gJ1xuXG4gICAgICAgIC8vIGRlZmF1bHQgdG8gZW1wdHkgc3RyaW5nIGZvciBmYWxzeSB2YWx1ZXMgZXhjZXB0IHplcm9cbiAgICAgICAgKyAobm9udWxsID09PSB0cnVlID8gJyF2JiZ2IT09MD9cIlwiOnYnIDogJ3YnKVxuXG4gICAgICArICd9fSkuY2FsbChkKSdcbiAgfVxuXG5cbiAgLy8gc3BsaXQgc3RyaW5nIGJ5IGFuIGFycmF5IG9mIHN1YnN0cmluZ3NcblxuICBmdW5jdGlvbiBzcGxpdChzdHIsIHN1YnN0cmluZ3MpIHtcbiAgICB2YXIgcGFydHMgPSBbXVxuICAgIHN1YnN0cmluZ3MubWFwKGZ1bmN0aW9uKHN1YiwgaSkge1xuXG4gICAgICAvLyBwdXNoIG1hdGNoZWQgZXhwcmVzc2lvbiBhbmQgcGFydCBiZWZvcmUgaXRcbiAgICAgIGkgPSBzdHIuaW5kZXhPZihzdWIpXG4gICAgICBwYXJ0cy5wdXNoKHN0ci5zbGljZSgwLCBpKSwgc3ViKVxuICAgICAgc3RyID0gc3RyLnNsaWNlKGkgKyBzdWIubGVuZ3RoKVxuICAgIH0pXG5cbiAgICAvLyBwdXNoIHRoZSByZW1haW5pbmcgcGFydFxuICAgIHJldHVybiBwYXJ0cy5jb25jYXQoc3RyKVxuICB9XG5cblxuICAvLyBtYXRjaCBzdHJpbmdzIGJldHdlZW4gb3BlbmluZyBhbmQgY2xvc2luZyByZWdleHAsIHNraXBwaW5nIGFueSBpbm5lci9uZXN0ZWQgbWF0Y2hlc1xuXG4gIGZ1bmN0aW9uIGV4dHJhY3Qoc3RyLCBvcGVuLCBjbG9zZSkge1xuXG4gICAgdmFyIHN0YXJ0LFxuICAgICAgICBsZXZlbCA9IDAsXG4gICAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKCcoJytvcGVuLnNvdXJjZSsnKXwoJytjbG9zZS5zb3VyY2UrJyknLCAnZycpXG5cbiAgICBzdHIucmVwbGFjZShyZSwgZnVuY3Rpb24oXywgb3BlbiwgY2xvc2UsIHBvcykge1xuXG4gICAgICAvLyBpZiBvdXRlciBpbm5lciBicmFja2V0LCBtYXJrIHBvc2l0aW9uXG4gICAgICBpZighbGV2ZWwgJiYgb3Blbikgc3RhcnQgPSBwb3NcblxuICAgICAgLy8gaW4oZGUpY3JlYXNlIGJyYWNrZXQgbGV2ZWxcbiAgICAgIGxldmVsICs9IG9wZW4gPyAxIDogLTFcblxuICAgICAgLy8gaWYgb3V0ZXIgY2xvc2luZyBicmFja2V0LCBncmFiIHRoZSBtYXRjaFxuICAgICAgaWYoIWxldmVsICYmIGNsb3NlICE9IG51bGwpIG1hdGNoZXMucHVzaChzdHIuc2xpY2Uoc3RhcnQsIHBvcytjbG9zZS5sZW5ndGgpKVxuXG4gICAgfSlcblxuICAgIHJldHVybiBtYXRjaGVzXG4gIH1cblxufSkoKVxuXG4vLyB7IGtleSwgaSBpbiBpdGVtc30gLT4geyBrZXksIGksIGl0ZW1zIH1cbmZ1bmN0aW9uIGxvb3BLZXlzKGV4cHIpIHtcbiAgdmFyIHJldCA9IHsgdmFsOiBleHByIH0sXG4gICAgICBlbHMgPSBleHByLnNwbGl0KC9cXHMraW5cXHMrLylcblxuICBpZiAoZWxzWzFdKSB7XG4gICAgcmV0LnZhbCA9IGJyYWNrZXRzKDApICsgZWxzWzFdXG4gICAgZWxzID0gZWxzWzBdLnNsaWNlKGJyYWNrZXRzKDApLmxlbmd0aCkudHJpbSgpLnNwbGl0KC8sXFxzKi8pXG4gICAgcmV0LmtleSA9IGVsc1swXVxuICAgIHJldC5wb3MgPSBlbHNbMV1cbiAgfVxuXG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbWtpdGVtKGV4cHIsIGtleSwgdmFsKSB7XG4gIHZhciBpdGVtID0ge31cbiAgaXRlbVtleHByLmtleV0gPSBrZXlcbiAgaWYgKGV4cHIucG9zKSBpdGVtW2V4cHIucG9zXSA9IHZhbFxuICByZXR1cm4gaXRlbVxufVxuXG5cbi8qIEJld2FyZTogaGVhdnkgc3R1ZmYgKi9cbmZ1bmN0aW9uIF9lYWNoKGRvbSwgcGFyZW50LCBleHByKSB7XG5cbiAgcmVtQXR0cihkb20sICdlYWNoJylcblxuICB2YXIgdGVtcGxhdGUgPSBkb20ub3V0ZXJIVE1MLFxuICAgICAgcHJldiA9IGRvbS5wcmV2aW91c1NpYmxpbmcsXG4gICAgICByb290ID0gZG9tLnBhcmVudE5vZGUsXG4gICAgICByZW5kZXJlZCA9IFtdLFxuICAgICAgdGFncyA9IFtdLFxuICAgICAgY2hlY2tzdW1cblxuICBleHByID0gbG9vcEtleXMoZXhwcilcblxuICBmdW5jdGlvbiBhZGQocG9zLCBpdGVtLCB0YWcpIHtcbiAgICByZW5kZXJlZC5zcGxpY2UocG9zLCAwLCBpdGVtKVxuICAgIHRhZ3Muc3BsaWNlKHBvcywgMCwgdGFnKVxuICB9XG5cbiAgLy8gY2xlYW4gdGVtcGxhdGUgY29kZVxuICBwYXJlbnQub25lKCd1cGRhdGUnLCBmdW5jdGlvbigpIHtcbiAgICByb290LnJlbW92ZUNoaWxkKGRvbSlcblxuICB9KS5vbmUoJ3ByZW1vdW50JywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJvb3Quc3R1Yikgcm9vdCA9IHBhcmVudC5yb290XG5cbiAgfSkub24oJ3VwZGF0ZScsIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGl0ZW1zID0gdG1wbChleHByLnZhbCwgcGFyZW50KVxuICAgIGlmICghaXRlbXMpIHJldHVyblxuXG4gICAgLy8gb2JqZWN0IGxvb3AuIGFueSBjaGFuZ2VzIGNhdXNlIGZ1bGwgcmVkcmF3XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgdmFyIHRlc3RzdW0gPSBKU09OLnN0cmluZ2lmeShpdGVtcylcblxuICAgICAgaWYgKHRlc3RzdW0gPT0gY2hlY2tzdW0pIHJldHVyblxuICAgICAgY2hlY2tzdW0gPSB0ZXN0c3VtXG5cbiAgICAgIC8vIGNsZWFyIG9sZCBpdGVtc1xuICAgICAgZWFjaCh0YWdzLCBmdW5jdGlvbih0YWcpIHsgdGFnLnVubW91bnQoKSB9KVxuICAgICAgcmVuZGVyZWQgPSBbXVxuICAgICAgdGFncyA9IFtdXG5cbiAgICAgIGl0ZW1zID0gT2JqZWN0LmtleXMoaXRlbXMpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIG1raXRlbShleHByLCBrZXksIGl0ZW1zW2tleV0pXG4gICAgICB9KVxuXG4gICAgfVxuXG4gICAgLy8gdW5tb3VudCByZWR1bmRhbnRcbiAgICBlYWNoKHJlbmRlcmVkLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAvLyBza2lwIGV4aXN0aW5nIGl0ZW1zXG4gICAgICAgIGlmIChpdGVtcy5pbmRleE9mKGl0ZW0pID4gLTEpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmluZCBhbGwgbm9uLW9iamVjdHNcbiAgICAgICAgdmFyIG5ld0l0ZW1zID0gYXJyRmluZEVxdWFscyhpdGVtcywgaXRlbSksXG4gICAgICAgICAgICBvbGRJdGVtcyA9IGFyckZpbmRFcXVhbHMocmVuZGVyZWQsIGl0ZW0pXG5cbiAgICAgICAgLy8gaWYgbW9yZSBvciBlcXVhbCBhbW91bnQsIG5vIG5lZWQgdG8gcmVtb3ZlXG4gICAgICAgIGlmIChuZXdJdGVtcy5sZW5ndGggPj0gb2xkSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBwb3MgPSByZW5kZXJlZC5pbmRleE9mKGl0ZW0pLFxuICAgICAgICAgIHRhZyA9IHRhZ3NbcG9zXVxuXG4gICAgICBpZiAodGFnKSB7XG4gICAgICAgIHRhZy51bm1vdW50KClcbiAgICAgICAgcmVuZGVyZWQuc3BsaWNlKHBvcywgMSlcbiAgICAgICAgdGFncy5zcGxpY2UocG9zLCAxKVxuICAgICAgICAvLyB0byBsZXQgXCJlYWNoXCIga25vdyB0aGF0IHRoaXMgaXRlbSBpcyByZW1vdmVkXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgfSlcblxuICAgIC8vIG1vdW50IG5ldyAvIHJlb3JkZXJcbiAgICB2YXIgcHJldkJhc2UgPSBbXS5pbmRleE9mLmNhbGwocm9vdC5jaGlsZE5vZGVzLCBwcmV2KSArIDFcbiAgICBlYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtLCBpKSB7XG5cbiAgICAgIC8vIHN0YXJ0IGluZGV4IHNlYXJjaCBmcm9tIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IGlcbiAgICAgIHZhciBwb3MgPSBpdGVtcy5pbmRleE9mKGl0ZW0sIGkpLFxuICAgICAgICAgIG9sZFBvcyA9IHJlbmRlcmVkLmluZGV4T2YoaXRlbSwgaSlcblxuICAgICAgLy8gaWYgbm90IGZvdW5kLCBzZWFyY2ggYmFja3dhcmRzIGZyb20gY3VycmVudCBpIHBvc2l0aW9uXG4gICAgICBwb3MgPCAwICYmIChwb3MgPSBpdGVtcy5sYXN0SW5kZXhPZihpdGVtLCBpKSlcbiAgICAgIG9sZFBvcyA8IDAgJiYgKG9sZFBvcyA9IHJlbmRlcmVkLmxhc3RJbmRleE9mKGl0ZW0sIGkpKVxuXG4gICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICAvLyBmaW5kIGFsbCBub24tb2JqZWN0c1xuICAgICAgICB2YXIgbmV3SXRlbXMgPSBhcnJGaW5kRXF1YWxzKGl0ZW1zLCBpdGVtKSxcbiAgICAgICAgICAgIG9sZEl0ZW1zID0gYXJyRmluZEVxdWFscyhyZW5kZXJlZCwgaXRlbSlcblxuICAgICAgICAvLyBpZiBtb3JlLCBzaG91bGQgbW91bnQgb25lIG5ld1xuICAgICAgICBpZiAobmV3SXRlbXMubGVuZ3RoID4gb2xkSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgb2xkUG9zID0gLTFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBtb3VudCBuZXdcbiAgICAgIHZhciBub2RlcyA9IHJvb3QuY2hpbGROb2Rlc1xuICAgICAgaWYgKG9sZFBvcyA8IDApIHtcbiAgICAgICAgaWYgKCFjaGVja3N1bSAmJiBleHByLmtleSkgdmFyIF9pdGVtID0gbWtpdGVtKGV4cHIsIGl0ZW0sIHBvcylcblxuICAgICAgICB2YXIgdGFnID0gbmV3IFRhZyh7IHRtcGw6IHRlbXBsYXRlIH0sIHtcbiAgICAgICAgICBiZWZvcmU6IG5vZGVzW3ByZXZCYXNlICsgcG9zXSxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgIGl0ZW06IF9pdGVtIHx8IGl0ZW1cbiAgICAgICAgfSlcblxuICAgICAgICB0YWcubW91bnQoKVxuXG4gICAgICAgIGFkZChwb3MsIGl0ZW0sIHRhZylcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gY2hhbmdlIHBvcyB2YWx1ZVxuICAgICAgaWYgKGV4cHIucG9zICYmIHRhZ3Nbb2xkUG9zXVtleHByLnBvc10gIT0gcG9zKSB7XG4gICAgICAgIHRhZ3Nbb2xkUG9zXS5vbmUoJ3VwZGF0ZScsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBpdGVtW2V4cHIucG9zXSA9IHBvc1xuICAgICAgICB9KVxuICAgICAgICB0YWdzW29sZFBvc10udXBkYXRlKClcbiAgICAgIH1cblxuICAgICAgLy8gcmVvcmRlclxuICAgICAgaWYgKHBvcyAhPSBvbGRQb3MpIHtcbiAgICAgICAgcm9vdC5pbnNlcnRCZWZvcmUobm9kZXNbcHJldkJhc2UgKyBvbGRQb3NdLCBub2Rlc1twcmV2QmFzZSArIChwb3MgPiBvbGRQb3MgPyBwb3MgKyAxIDogcG9zKV0pXG4gICAgICAgIHJldHVybiBhZGQocG9zLCByZW5kZXJlZC5zcGxpY2Uob2xkUG9zLCAxKVswXSwgdGFncy5zcGxpY2Uob2xkUG9zLCAxKVswXSlcbiAgICAgIH1cblxuICAgIH0pXG5cbiAgICByZW5kZXJlZCA9IGl0ZW1zLnNsaWNlKClcblxuICB9KS5vbmUoJ3VwZGF0ZWQnLCBmdW5jdGlvbigpIHtcbiAgICB3YWxrKHJvb3QsIGZ1bmN0aW9uKGRvbSkge1xuICAgICAgZWFjaChkb20uYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBpZiAoL14obmFtZXxpZCkkLy50ZXN0KGF0dHIubmFtZSkpIHBhcmVudFthdHRyLnZhbHVlXSA9IGRvbVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG59XG5cblxuZnVuY3Rpb24gcGFyc2VOYW1lZEVsZW1lbnRzKHJvb3QsIHBhcmVudCwgY2hpbGRUYWdzKSB7XG5cbiAgd2Fsayhyb290LCBmdW5jdGlvbihkb20pIHtcbiAgICBpZiAoZG9tLm5vZGVUeXBlID09IDEpIHtcbiAgICAgIGRvbS5pc0xvb3AgPSAwXG4gICAgICBpZihkb20ucGFyZW50Tm9kZSAmJiBkb20ucGFyZW50Tm9kZS5pc0xvb3ApIGRvbS5pc0xvb3AgPSAxXG4gICAgICBpZihkb20uZ2V0QXR0cmlidXRlKCdlYWNoJykpIGRvbS5pc0xvb3AgPSAxXG4gICAgICAvLyBjdXN0b20gY2hpbGQgdGFnXG4gICAgICB2YXIgY2hpbGQgPSBnZXRUYWcoZG9tKVxuXG4gICAgICBpZiAoY2hpbGQgJiYgIWRvbS5pc0xvb3ApIHtcbiAgICAgICAgdmFyIHRhZyA9IG5ldyBUYWcoY2hpbGQsIHsgcm9vdDogZG9tLCBwYXJlbnQ6IHBhcmVudCB9LCBkb20uaW5uZXJIVE1MKSxcbiAgICAgICAgICAgIG5hbWVkVGFnID0gZG9tLmdldEF0dHJpYnV0ZSgnbmFtZScpLFxuICAgICAgICAgICAgdGFnTmFtZSA9IG5hbWVkVGFnICYmIG5hbWVkVGFnLmluZGV4T2YoYnJhY2tldHMoMCkpIDwgMCA/IG5hbWVkVGFnIDogY2hpbGQubmFtZSxcbiAgICAgICAgICAgIHB0YWcgPSBwYXJlbnQsXG4gICAgICAgICAgICBjYWNoZWRUYWdcblxuICAgICAgICB3aGlsZSghZ2V0VGFnKHB0YWcucm9vdCkpIHtcbiAgICAgICAgICBpZighcHRhZy5wYXJlbnQpIGJyZWFrXG4gICAgICAgICAgcHRhZyA9IHB0YWcucGFyZW50XG4gICAgICAgIH1cbiAgICAgICAgLy8gZml4IGZvciB0aGUgcGFyZW50IGF0dHJpYnV0ZSBpbiB0aGUgbG9vcGVkIGVsZW1lbnRzXG4gICAgICAgIHRhZy5wYXJlbnQgPSBwdGFnXG5cbiAgICAgICAgY2FjaGVkVGFnID0gcHRhZy50YWdzW3RhZ05hbWVdXG5cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG11bHRpcGxlIGNoaWxkcmVuIHRhZ3MgaGF2aW5nIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgaWYgKGNhY2hlZFRhZykge1xuICAgICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgdGFncyBwcm9wZXJ0eSBpcyBub3QgeWV0IGFuIGFycmF5XG4gICAgICAgICAgLy8gY3JlYXRlIGl0IGFkZGluZyB0aGUgZmlyc3QgY2FjaGVkIHRhZ1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjYWNoZWRUYWcpKVxuICAgICAgICAgICAgcHRhZy50YWdzW3RhZ05hbWVdID0gW2NhY2hlZFRhZ11cbiAgICAgICAgICAvLyBhZGQgdGhlIG5ldyBuZXN0ZWQgdGFnIHRvIHRoZSBhcnJheVxuICAgICAgICAgIHB0YWcudGFnc1t0YWdOYW1lXS5wdXNoKHRhZylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdGFnLnRhZ3NbdGFnTmFtZV0gPSB0YWdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtcHR5IHRoZSBjaGlsZCBub2RlIG9uY2Ugd2UgZ290IGl0cyB0ZW1wbGF0ZVxuICAgICAgICAvLyB0byBhdm9pZCB0aGF0IGl0cyBjaGlsZHJlbiBnZXQgY29tcGlsZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgZG9tLmlubmVySFRNTCA9ICcnXG4gICAgICAgIGNoaWxkVGFncy5wdXNoKHRhZylcbiAgICAgIH1cblxuICAgICAgaWYoIWRvbS5pc0xvb3ApXG4gICAgICAgIGVhY2goZG9tLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICBpZiAoL14obmFtZXxpZCkkLy50ZXN0KGF0dHIubmFtZSkpIHBhcmVudFthdHRyLnZhbHVlXSA9IGRvbVxuICAgICAgICB9KVxuICAgIH1cblxuICB9KVxuXG59XG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbnMocm9vdCwgdGFnLCBleHByZXNzaW9ucykge1xuXG4gIGZ1bmN0aW9uIGFkZEV4cHIoZG9tLCB2YWwsIGV4dHJhKSB7XG4gICAgaWYgKHZhbC5pbmRleE9mKGJyYWNrZXRzKDApKSA+PSAwKSB7XG4gICAgICB2YXIgZXhwciA9IHsgZG9tOiBkb20sIGV4cHI6IHZhbCB9XG4gICAgICBleHByZXNzaW9ucy5wdXNoKGV4dGVuZChleHByLCBleHRyYSkpXG4gICAgfVxuICB9XG5cbiAgd2Fsayhyb290LCBmdW5jdGlvbihkb20pIHtcbiAgICB2YXIgdHlwZSA9IGRvbS5ub2RlVHlwZVxuXG4gICAgLy8gdGV4dCBub2RlXG4gICAgaWYgKHR5cGUgPT0gMyAmJiBkb20ucGFyZW50Tm9kZS50YWdOYW1lICE9ICdTVFlMRScpIGFkZEV4cHIoZG9tLCBkb20ubm9kZVZhbHVlKVxuICAgIGlmICh0eXBlICE9IDEpIHJldHVyblxuXG4gICAgLyogZWxlbWVudCAqL1xuXG4gICAgLy8gbG9vcFxuICAgIHZhciBhdHRyID0gZG9tLmdldEF0dHJpYnV0ZSgnZWFjaCcpXG4gICAgaWYgKGF0dHIpIHsgX2VhY2goZG9tLCB0YWcsIGF0dHIpOyByZXR1cm4gZmFsc2UgfVxuXG4gICAgLy8gYXR0cmlidXRlIGV4cHJlc3Npb25zXG4gICAgZWFjaChkb20uYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyLm5hbWUsXG4gICAgICAgIGJvb2wgPSBuYW1lLnNwbGl0KCdfXycpWzFdXG5cbiAgICAgIGFkZEV4cHIoZG9tLCBhdHRyLnZhbHVlLCB7IGF0dHI6IGJvb2wgfHwgbmFtZSwgYm9vbDogYm9vbCB9KVxuICAgICAgaWYgKGJvb2wpIHsgcmVtQXR0cihkb20sIG5hbWUpOyByZXR1cm4gZmFsc2UgfVxuXG4gICAgfSlcblxuICAgIC8vIHNraXAgY3VzdG9tIHRhZ3NcbiAgICBpZiAoZ2V0VGFnKGRvbSkpIHJldHVybiBmYWxzZVxuXG4gIH0pXG5cbn1cbmZ1bmN0aW9uIFRhZyhpbXBsLCBjb25mLCBpbm5lckhUTUwpIHtcblxuICB2YXIgc2VsZiA9IHJpb3Qub2JzZXJ2YWJsZSh0aGlzKSxcbiAgICAgIG9wdHMgPSBpbmhlcml0KGNvbmYub3B0cykgfHwge30sXG4gICAgICBkb20gPSBta2RvbShpbXBsLnRtcGwpLFxuICAgICAgcGFyZW50ID0gY29uZi5wYXJlbnQsXG4gICAgICBleHByZXNzaW9ucyA9IFtdLFxuICAgICAgY2hpbGRUYWdzID0gW10sXG4gICAgICByb290ID0gY29uZi5yb290LFxuICAgICAgaXRlbSA9IGNvbmYuaXRlbSxcbiAgICAgIGZuID0gaW1wbC5mbixcbiAgICAgIHRhZ05hbWUgPSByb290LnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgIGF0dHIgPSB7fSxcbiAgICAgIGxvb3BEb20sXG4gICAgICBUQUdfQVRUUklCVVRFUyA9IC8oW1xcd1xcLV0rKVxccz89XFxzP1snXCJdKFteJ1wiXSspW1wiJ10vZ2ltXG5cbiAgaWYgKGZuICYmIHJvb3QuX3RhZykge1xuICAgIHJvb3QuX3RhZy51bm1vdW50KHRydWUpXG4gIH1cblxuICBpZihpbXBsLmF0dHJzKSB7XG4gICAgdmFyIGF0dHJzID0gaW1wbC5hdHRycy5tYXRjaChUQUdfQVRUUklCVVRFUylcblxuICAgIGVhY2goYXR0cnMsIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBrdiA9IGEuc3BsaXQoL1xccz89XFxzPy8pXG4gICAgICByb290LnNldEF0dHJpYnV0ZShrdlswXSwga3ZbMV0ucmVwbGFjZSgvWydcIl0vZywgJycpKVxuICAgIH0pXG5cbiAgfVxuICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB0YWcganVzdCBjcmVhdGVkXG4gIC8vIHNvIHdlIHdpbGwgYmUgYWJsZSB0byBtb3VudCB0aGlzIHRhZyBtdWx0aXBsZSB0aW1lc1xuICByb290Ll90YWcgPSB0aGlzXG5cbiAgLy8gY3JlYXRlIGEgdW5pcXVlIGlkIHRvIHRoaXMgdGFnXG4gIC8vIGl0IGNvdWxkIGJlIGhhbmR5IHRvIHVzZSBpdCBhbHNvIHRvIGltcHJvdmUgdGhlIHZpcnR1YWwgZG9tIHJlbmRlcmluZyBzcGVlZFxuICB0aGlzLl9pZCA9IGZhc3RBYnMofn4obmV3IERhdGUoKS5nZXRUaW1lKCkgKiBNYXRoLnJhbmRvbSgpKSlcblxuICBleHRlbmQodGhpcywgeyBwYXJlbnQ6IHBhcmVudCwgcm9vdDogcm9vdCwgb3B0czogb3B0cywgdGFnczoge30gfSwgaXRlbSlcblxuICAvLyBncmFiIGF0dHJpYnV0ZXNcbiAgZWFjaChyb290LmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGVsKSB7XG4gICAgYXR0cltlbC5uYW1lXSA9IGVsLnZhbHVlXG4gIH0pXG5cblxuICBpZiAoZG9tLmlubmVySFRNTCAmJiAhL3NlbGVjdC8udGVzdCh0YWdOYW1lKSAmJiAhL3Rib2R5Ly50ZXN0KHRhZ05hbWUpICYmICEvdHIvLnRlc3QodGFnTmFtZSkpXG4gICAgLy8gcmVwbGFjZSBhbGwgdGhlIHlpZWxkIHRhZ3Mgd2l0aCB0aGUgdGFnIGlubmVyIGh0bWxcbiAgICBkb20uaW5uZXJIVE1MID0gcmVwbGFjZVlpZWxkKGRvbS5pbm5lckhUTUwsIGlubmVySFRNTClcblxuXG4gIC8vIG9wdGlvbnNcbiAgZnVuY3Rpb24gdXBkYXRlT3B0cygpIHtcbiAgICBlYWNoKE9iamVjdC5rZXlzKGF0dHIpLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBvcHRzW25hbWVdID0gdG1wbChhdHRyW25hbWVdLCBwYXJlbnQgfHwgc2VsZilcbiAgICB9KVxuICB9XG5cbiAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihkYXRhLCBpbml0KSB7XG4gICAgZXh0ZW5kKHNlbGYsIGRhdGEsIGl0ZW0pXG4gICAgdXBkYXRlT3B0cygpXG4gICAgc2VsZi50cmlnZ2VyKCd1cGRhdGUnLCBpdGVtKVxuICAgIHVwZGF0ZShleHByZXNzaW9ucywgc2VsZiwgaXRlbSlcbiAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZWQnKVxuICB9XG5cbiAgdGhpcy5taXhpbiA9IGZ1bmN0aW9uKCkge1xuICAgIGVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihtaXgpIHtcbiAgICAgIG1peCA9ICdzdHJpbmcnID09IHR5cGVvZiBtaXggPyByaW90Lm1peGluKG1peCkgOiBtaXhcbiAgICAgIGVhY2goT2JqZWN0LmtleXMobWl4KSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIC8vIGJpbmQgbWV0aG9kcyB0byBzZWxmXG4gICAgICAgIGlmICgnaW5pdCcgIT0ga2V5KVxuICAgICAgICAgIHNlbGZba2V5XSA9ICdmdW5jdGlvbicgPT0gdHlwZW9mIG1peFtrZXldID8gbWl4W2tleV0uYmluZChzZWxmKSA6IG1peFtrZXldXG4gICAgICB9KVxuICAgICAgLy8gaW5pdCBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseVxuICAgICAgaWYgKG1peC5pbml0KSBtaXguaW5pdC5iaW5kKHNlbGYpKClcbiAgICB9KVxuICB9XG5cbiAgdGhpcy5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdXBkYXRlT3B0cygpXG5cbiAgICAvLyBpbml0aWFsaWF0aW9uXG4gICAgZm4gJiYgZm4uY2FsbChzZWxmLCBvcHRzKVxuXG4gICAgdG9nZ2xlKHRydWUpXG5cbiAgICAvLyBwYXJzZSBsYXlvdXQgYWZ0ZXIgaW5pdC4gZm4gbWF5IGNhbGN1bGF0ZSBhcmdzIGZvciBuZXN0ZWQgY3VzdG9tIHRhZ3NcbiAgICBwYXJzZUV4cHJlc3Npb25zKGRvbSwgc2VsZiwgZXhwcmVzc2lvbnMpXG5cbiAgICBpZiAoIXNlbGYucGFyZW50KSBzZWxmLnVwZGF0ZSgpXG5cbiAgICAvLyBpbnRlcm5hbCB1c2Ugb25seSwgZml4ZXMgIzQwM1xuICAgIHNlbGYudHJpZ2dlcigncHJlbW91bnQnKVxuXG4gICAgaWYgKGZuKSB7XG4gICAgICB3aGlsZSAoZG9tLmZpcnN0Q2hpbGQpIHJvb3QuYXBwZW5kQ2hpbGQoZG9tLmZpcnN0Q2hpbGQpXG5cbiAgICB9IGVsc2Uge1xuICAgICAgbG9vcERvbSA9IGRvbS5maXJzdENoaWxkXG4gICAgICByb290Lmluc2VydEJlZm9yZShsb29wRG9tLCBjb25mLmJlZm9yZSB8fCBudWxsKSAvLyBudWxsIG5lZWRlZCBmb3IgSUU4XG4gICAgfVxuXG4gICAgaWYgKHJvb3Quc3R1Yikgc2VsZi5yb290ID0gcm9vdCA9IHBhcmVudC5yb290XG5cbiAgICAvLyBpZiBpdCdzIG5vdCBhIGNoaWxkIHRhZyB3ZSBjYW4gdHJpZ2dlciBpdHMgbW91bnQgZXZlbnRcbiAgICBpZiAoIXNlbGYucGFyZW50KSBzZWxmLnRyaWdnZXIoJ21vdW50JylcbiAgICAvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byB3YWl0IHRoYXQgdGhlIHBhcmVudCBldmVudCBnZXRzIHRyaWdnZXJlZFxuICAgIGVsc2Ugc2VsZi5wYXJlbnQub25lKCdtb3VudCcsIGZ1bmN0aW9uKCkgeyBzZWxmLnRyaWdnZXIoJ21vdW50JykgfSlcbiAgfVxuXG5cbiAgdGhpcy51bm1vdW50ID0gZnVuY3Rpb24oa2VlcFJvb3RUYWcpIHtcbiAgICB2YXIgZWwgPSBmbiA/IHJvb3QgOiBsb29wRG9tLFxuICAgICAgICBwID0gZWwucGFyZW50Tm9kZVxuXG4gICAgaWYgKHApIHtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyByZW1vdmUgdGhpcyB0YWcgZnJvbSB0aGUgcGFyZW50IHRhZ3Mgb2JqZWN0XG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBuZXN0ZWQgdGFncyB3aXRoIHNhbWUgbmFtZS4uXG4gICAgICAgIC8vIHJlbW92ZSB0aGlzIGVsZW1lbnQgZm9ybSB0aGUgYXJyYXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyZW50LnRhZ3NbdGFnTmFtZV0pKSB7XG4gICAgICAgICAgZWFjaChwYXJlbnQudGFnc1t0YWdOYW1lXSwgZnVuY3Rpb24odGFnLCBpKSB7XG4gICAgICAgICAgICBpZiAodGFnLl9pZCA9PSBzZWxmLl9pZClcbiAgICAgICAgICAgICAgcGFyZW50LnRhZ3NbdGFnTmFtZV0uc3BsaWNlKGksIDEpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgZGVsZXRlIHRoZSB0YWcgaW5zdGFuY2VcbiAgICAgICAgICBwYXJlbnQudGFnc1t0YWdOYW1lXSA9IHVuZGVmaW5lZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpXG4gICAgICB9XG5cbiAgICAgIGlmICgha2VlcFJvb3RUYWcpXG4gICAgICAgIHAucmVtb3ZlQ2hpbGQoZWwpXG5cbiAgICB9XG5cblxuICAgIHNlbGYudHJpZ2dlcigndW5tb3VudCcpXG4gICAgdG9nZ2xlKClcbiAgICBzZWxmLm9mZignKicpXG4gICAgLy8gc29tZWhvdyBpZTggZG9lcyBub3QgbGlrZSBgZGVsZXRlIHJvb3QuX3RhZ2BcbiAgICByb290Ll90YWcgPSBudWxsXG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZShpc01vdW50KSB7XG5cbiAgICAvLyBtb3VudC91bm1vdW50IGNoaWxkcmVuXG4gICAgZWFjaChjaGlsZFRhZ3MsIGZ1bmN0aW9uKGNoaWxkKSB7IGNoaWxkW2lzTW91bnQgPyAnbW91bnQnIDogJ3VubW91bnQnXSgpIH0pXG5cbiAgICAvLyBsaXN0ZW4vdW5saXN0ZW4gcGFyZW50IChldmVudHMgZmxvdyBvbmUgd2F5IGZyb20gcGFyZW50IHRvIGNoaWxkcmVuKVxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHZhciBldnQgPSBpc01vdW50ID8gJ29uJyA6ICdvZmYnXG4gICAgICBwYXJlbnRbZXZ0XSgndXBkYXRlJywgc2VsZi51cGRhdGUpW2V2dF0oJ3VubW91bnQnLCBzZWxmLnVubW91bnQpXG4gICAgfVxuICB9XG5cbiAgLy8gbmFtZWQgZWxlbWVudHMgYXZhaWxhYmxlIGZvciBmblxuICBwYXJzZU5hbWVkRWxlbWVudHMoZG9tLCB0aGlzLCBjaGlsZFRhZ3MpXG5cblxufVxuXG5mdW5jdGlvbiBzZXRFdmVudEhhbmRsZXIobmFtZSwgaGFuZGxlciwgZG9tLCB0YWcsIGl0ZW0pIHtcblxuICBkb21bbmFtZV0gPSBmdW5jdGlvbihlKSB7XG5cbiAgICAvLyBjcm9zcyBicm93c2VyIGV2ZW50IGZpeFxuICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudFxuICAgIGUud2hpY2ggPSBlLndoaWNoIHx8IGUuY2hhckNvZGUgfHwgZS5rZXlDb2RlXG4gICAgZS50YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnRcbiAgICBlLmN1cnJlbnRUYXJnZXQgPSBkb21cbiAgICBlLml0ZW0gPSBpdGVtXG5cbiAgICAvLyBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3VyIChieSBkZWZhdWx0KVxuICAgIGlmIChoYW5kbGVyLmNhbGwodGFnLCBlKSAhPT0gdHJ1ZSAmJiAhL3JhZGlvfGNoZWNrLy50ZXN0KGRvbS50eXBlKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICghZS5wcmV2ZW50VXBkYXRlKSB7XG4gICAgICB2YXIgZWwgPSBpdGVtID8gdGFnLnBhcmVudCA6IHRhZ1xuICAgICAgZWwudXBkYXRlKClcbiAgICB9XG5cbiAgfVxuXG59XG5cbi8vIHVzZWQgYnkgaWYtIGF0dHJpYnV0ZVxuZnVuY3Rpb24gaW5zZXJ0VG8ocm9vdCwgbm9kZSwgYmVmb3JlKSB7XG4gIGlmIChyb290KSB7XG4gICAgcm9vdC5pbnNlcnRCZWZvcmUoYmVmb3JlLCBub2RlKVxuICAgIHJvb3QucmVtb3ZlQ2hpbGQobm9kZSlcbiAgfVxufVxuXG4vLyBpdGVtID0gY3VycmVudGx5IGxvb3BlZCBpdGVtXG5mdW5jdGlvbiB1cGRhdGUoZXhwcmVzc2lvbnMsIHRhZywgaXRlbSkge1xuXG4gIGVhY2goZXhwcmVzc2lvbnMsIGZ1bmN0aW9uKGV4cHIsIGkpIHtcblxuICAgIHZhciBkb20gPSBleHByLmRvbSxcbiAgICAgICAgYXR0ck5hbWUgPSBleHByLmF0dHIsXG4gICAgICAgIHZhbHVlID0gdG1wbChleHByLmV4cHIsIHRhZyksXG4gICAgICAgIHBhcmVudCA9IGV4cHIuZG9tLnBhcmVudE5vZGVcblxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB2YWx1ZSA9ICcnXG5cbiAgICAvLyBsZWF2ZSBvdXQgcmlvdC0gcHJlZml4ZXMgZnJvbSBzdHJpbmdzIGluc2lkZSB0ZXh0YXJlYVxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnRhZ05hbWUgPT0gJ1RFWFRBUkVBJykgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9yaW90LS9nLCAnJylcblxuICAgIC8vIG5vIGNoYW5nZVxuICAgIGlmIChleHByLnZhbHVlID09PSB2YWx1ZSkgcmV0dXJuXG4gICAgZXhwci52YWx1ZSA9IHZhbHVlXG5cbiAgICAvLyB0ZXh0IG5vZGVcbiAgICBpZiAoIWF0dHJOYW1lKSByZXR1cm4gZG9tLm5vZGVWYWx1ZSA9IHZhbHVlLnRvU3RyaW5nKClcblxuICAgIC8vIHJlbW92ZSBvcmlnaW5hbCBhdHRyaWJ1dGVcbiAgICByZW1BdHRyKGRvbSwgYXR0ck5hbWUpXG5cbiAgICAvLyBldmVudCBoYW5kbGVyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZXRFdmVudEhhbmRsZXIoYXR0ck5hbWUsIHZhbHVlLCBkb20sIHRhZywgaXRlbSlcblxuICAgIC8vIGlmLSBjb25kaXRpb25hbFxuICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT0gJ2lmJykge1xuICAgICAgdmFyIHN0dWIgPSBleHByLnN0dWJcblxuICAgICAgLy8gYWRkIHRvIERPTVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHN0dWIgJiYgaW5zZXJ0VG8oc3R1Yi5wYXJlbnROb2RlLCBzdHViLCBkb20pXG5cbiAgICAgIC8vIHJlbW92ZSBmcm9tIERPTVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R1YiA9IGV4cHIuc3R1YiA9IHN0dWIgfHwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpXG4gICAgICAgIGluc2VydFRvKGRvbS5wYXJlbnROb2RlLCBkb20sIHN0dWIpXG4gICAgICB9XG5cbiAgICAvLyBzaG93IC8gaGlkZVxuICAgIH0gZWxzZSBpZiAoL14oc2hvd3xoaWRlKSQvLnRlc3QoYXR0ck5hbWUpKSB7XG4gICAgICBpZiAoYXR0ck5hbWUgPT0gJ2hpZGUnKSB2YWx1ZSA9ICF2YWx1ZVxuICAgICAgZG9tLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/ICcnIDogJ25vbmUnXG5cbiAgICAvLyBmaWVsZCB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT0gJ3ZhbHVlJykge1xuICAgICAgZG9tLnZhbHVlID0gdmFsdWVcblxuICAgIC8vIDxpbWcgc3JjPVwieyBleHByIH1cIj5cbiAgICB9IGVsc2UgaWYgKGF0dHJOYW1lLnNsaWNlKDAsIDUpID09ICdyaW90LScpIHtcbiAgICAgIGF0dHJOYW1lID0gYXR0ck5hbWUuc2xpY2UoNSlcbiAgICAgIHZhbHVlID8gZG9tLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgdmFsdWUpIDogcmVtQXR0cihkb20sIGF0dHJOYW1lKVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChleHByLmJvb2wpIHtcbiAgICAgICAgZG9tW2F0dHJOYW1lXSA9IHZhbHVlXG4gICAgICAgIGlmICghdmFsdWUpIHJldHVyblxuICAgICAgICB2YWx1ZSA9IGF0dHJOYW1lXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ29iamVjdCcpIGRvbS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIHZhbHVlKVxuXG4gICAgfVxuXG4gIH0pXG5cbn1cblxuZnVuY3Rpb24gZWFjaChlbHMsIGZuKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSAoZWxzIHx8IFtdKS5sZW5ndGgsIGVsOyBpIDwgbGVuOyBpKyspIHtcbiAgICBlbCA9IGVsc1tpXVxuICAgIC8vIHJldHVybiBmYWxzZSAtPiByZW1vdmUgY3VycmVudCBpdGVtIGR1cmluZyBsb29wXG4gICAgaWYgKGVsICE9IG51bGwgJiYgZm4oZWwsIGkpID09PSBmYWxzZSkgaS0tXG4gIH1cbiAgcmV0dXJuIGVsc1xufVxuXG5mdW5jdGlvbiByZW1BdHRyKGRvbSwgbmFtZSkge1xuICBkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpXG59XG5cbmZ1bmN0aW9uIGZhc3RBYnMobnIpIHtcbiAgcmV0dXJuIChuciBeIChuciA+PiAzMSkpIC0gKG5yID4+IDMxKVxufVxuXG4vLyBtYXggMiBmcm9tIG9iamVjdHMgYWxsb3dlZFxuZnVuY3Rpb24gZXh0ZW5kKG9iaiwgZnJvbSwgZnJvbTIpIHtcbiAgZnJvbSAmJiBlYWNoKE9iamVjdC5rZXlzKGZyb20pLCBmdW5jdGlvbihrZXkpIHtcbiAgICBvYmpba2V5XSA9IGZyb21ba2V5XVxuICB9KVxuICByZXR1cm4gZnJvbTIgPyBleHRlbmQob2JqLCBmcm9tMikgOiBvYmpcbn1cblxuZnVuY3Rpb24gY2hlY2tJRSgpIHtcbiAgaWYgKHdpbmRvdykge1xuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnRcbiAgICB2YXIgbXNpZSA9IHVhLmluZGV4T2YoJ01TSUUgJylcbiAgICBpZiAobXNpZSA+IDApIHtcbiAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcobXNpZSArIDUsIHVhLmluZGV4T2YoJy4nLCBtc2llKSksIDEwKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9wdGlvbklubmVySFRNTChlbCwgaHRtbCkge1xuICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyksXG4gICAgICB2YWxSZWd4ID0gL3ZhbHVlPVtcXFwiJ10oLis/KVtcXFwiJ10vLFxuICAgICAgc2VsUmVneCA9IC9zZWxlY3RlZD1bXFxcIiddKC4rPylbXFxcIiddLyxcbiAgICAgIHZhbHVlc01hdGNoID0gaHRtbC5tYXRjaCh2YWxSZWd4KSxcbiAgICAgIHNlbGVjdGVkTWF0Y2ggPSBodG1sLm1hdGNoKHNlbFJlZ3gpXG5cbiAgb3B0LmlubmVySFRNTCA9IGh0bWxcblxuICBpZiAodmFsdWVzTWF0Y2gpIHtcbiAgICBvcHQudmFsdWUgPSB2YWx1ZXNNYXRjaFsxXVxuICB9XG5cbiAgaWYgKHNlbGVjdGVkTWF0Y2gpIHtcbiAgICBvcHQuc2V0QXR0cmlidXRlKCdyaW90LXNlbGVjdGVkJywgc2VsZWN0ZWRNYXRjaFsxXSlcbiAgfVxuXG4gIGVsLmFwcGVuZENoaWxkKG9wdClcbn1cblxuZnVuY3Rpb24gdGJvZHlJbm5lckhUTUwoZWwsIGh0bWwsIHRhZ05hbWUpIHtcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGRpdi5pbm5lckhUTUwgPSAnPHRhYmxlPicgKyBodG1sICsgJzwvdGFibGU+J1xuXG4gIGlmICgvdGR8dGgvLnRlc3QodGFnTmFtZSkpIHtcbiAgICBlbC5hcHBlbmRDaGlsZChkaXYuZmlyc3RDaGlsZC5maXJzdENoaWxkLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZClcbiAgfSBlbHNlIHtcbiAgICBlbC5hcHBlbmRDaGlsZChkaXYuZmlyc3RDaGlsZC5maXJzdENoaWxkLmZpcnN0Q2hpbGQpXG4gIH1cbn1cblxuZnVuY3Rpb24gbWtkb20odGVtcGxhdGUpIHtcbiAgdmFyIHRhZ05hbWUgPSB0ZW1wbGF0ZS50cmltKCkuc2xpY2UoMSwgMykudG9Mb3dlckNhc2UoKSxcbiAgICAgIHJvb3RUYWcgPSAvdGR8dGgvLnRlc3QodGFnTmFtZSkgPyAndHInIDogdGFnTmFtZSA9PSAndHInID8gJ3Rib2R5JyA6ICdkaXYnLFxuICAgICAgZWwgPSBta0VsKHJvb3RUYWcpXG5cbiAgZWwuc3R1YiA9IHRydWVcblxuICBpZiAodGFnTmFtZSA9PT0gJ29wJyAmJiBpZVZlcnNpb24gJiYgaWVWZXJzaW9uIDwgMTApIHtcbiAgICBvcHRpb25Jbm5lckhUTUwoZWwsIHRlbXBsYXRlKVxuICB9IGVsc2UgaWYgKChyb290VGFnID09PSAndGJvZHknIHx8IHJvb3RUYWcgPT09ICd0cicpICYmIGllVmVyc2lvbiAmJiBpZVZlcnNpb24gPCAxMCkge1xuICAgIHRib2R5SW5uZXJIVE1MKGVsLCB0ZW1wbGF0ZSwgdGFnTmFtZSlcbiAgfSBlbHNlXG4gICAgZWwuaW5uZXJIVE1MID0gdGVtcGxhdGVcblxuICByZXR1cm4gZWxcbn1cblxuZnVuY3Rpb24gd2Fsayhkb20sIGZuKSB7XG4gIGlmIChkb20pIHtcbiAgICBpZiAoZm4oZG9tKSA9PT0gZmFsc2UpIHdhbGsoZG9tLm5leHRTaWJsaW5nLCBmbilcbiAgICBlbHNlIHtcbiAgICAgIGRvbSA9IGRvbS5maXJzdENoaWxkXG5cbiAgICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgd2Fsayhkb20sIGZuKVxuICAgICAgICBkb20gPSBkb20ubmV4dFNpYmxpbmdcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWtFbChuYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VZaWVsZCAodG1wbCwgaW5uZXJIVE1MKSB7XG4gIHJldHVybiB0bXBsLnJlcGxhY2UoLzwoeWllbGQpXFwvPz4oPFxcL1xcMT4pPy9naW0sIGlubmVySFRNTCB8fCAnJylcbn1cblxuZnVuY3Rpb24gJCQoc2VsZWN0b3IsIGN0eCkge1xuICBjdHggPSBjdHggfHwgZG9jdW1lbnRcbiAgcmV0dXJuIGN0eC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVxufVxuXG5mdW5jdGlvbiBhcnJEaWZmKGFycjEsIGFycjIpIHtcbiAgcmV0dXJuIGFycjEuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGFycjIuaW5kZXhPZihlbCkgPCAwXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFyckZpbmRFcXVhbHMoYXJyLCBlbCkge1xuICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoX2VsKSB7XG4gICAgcmV0dXJuIF9lbCA9PT0gZWxcbiAgfSlcbn1cblxuZnVuY3Rpb24gaW5oZXJpdChwYXJlbnQpIHtcbiAgZnVuY3Rpb24gQ2hpbGQoKSB7fVxuICBDaGlsZC5wcm90b3R5cGUgPSBwYXJlbnRcbiAgcmV0dXJuIG5ldyBDaGlsZCgpXG59XG4vKipcbiAqXG4gKiBIYWNrcyBuZWVkZWQgZm9yIHRoZSBvbGQgaW50ZXJuZXQgZXhwbG9yZXIgdmVyc2lvbnMgW2xvd2VyIHRoYW4gSUUxMF1cbiAqXG4gKi9cblxudmFyIGllVmVyc2lvbiA9IGNoZWNrSUUoKVxuXG5mdW5jdGlvbiBjaGVja0lFKCkge1xuICBpZiAod2luZG93KSB7XG4gICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgIHZhciBtc2llID0gdWEuaW5kZXhPZignTVNJRSAnKVxuICAgIGlmIChtc2llID4gMCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhtc2llICsgNSwgdWEuaW5kZXhPZignLicsIG1zaWUpKSwgMTApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGJvZHlJbm5lckhUTUwoZWwsIGh0bWwsIHRhZ05hbWUpIHtcbiAgdmFyIGRpdiA9IG1rRWwoJ2RpdicpLFxuICAgICAgbG9vcHMgPSAvdGR8dGgvLnRlc3QodGFnTmFtZSkgPyAzIDogMixcbiAgICAgIGNoaWxkXG5cbiAgZGl2LmlubmVySFRNTCA9ICc8dGFibGU+JyArIGh0bWwgKyAnPC90YWJsZT4nXG4gIGNoaWxkID0gZGl2LmZpcnN0Q2hpbGRcblxuICB3aGlsZShsb29wcy0tKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5maXJzdENoaWxkXG4gIH1cblxuICBlbC5hcHBlbmRDaGlsZChjaGlsZClcblxufVxuXG5mdW5jdGlvbiBvcHRpb25Jbm5lckhUTUwoZWwsIGh0bWwpIHtcbiAgdmFyIG9wdCA9IG1rRWwoJ29wdGlvbicpLFxuICAgICAgdmFsUmVneCA9IC92YWx1ZT1bXFxcIiddKC4rPylbXFxcIiddLyxcbiAgICAgIHNlbFJlZ3ggPSAvc2VsZWN0ZWQ9W1xcXCInXSguKz8pW1xcXCInXS8sXG4gICAgICB2YWx1ZXNNYXRjaCA9IGh0bWwubWF0Y2godmFsUmVneCksXG4gICAgICBzZWxlY3RlZE1hdGNoID0gaHRtbC5tYXRjaChzZWxSZWd4KVxuXG4gIG9wdC5pbm5lckhUTUwgPSBodG1sXG5cbiAgaWYgKHZhbHVlc01hdGNoKSB7XG4gICAgb3B0LnZhbHVlID0gdmFsdWVzTWF0Y2hbMV1cbiAgfVxuXG4gIGlmIChzZWxlY3RlZE1hdGNoKSB7XG4gICAgb3B0LnNldEF0dHJpYnV0ZSgncmlvdC1zZWxlY3RlZCcsIHNlbGVjdGVkTWF0Y2hbMV0pXG4gIH1cblxuICBlbC5hcHBlbmRDaGlsZChvcHQpXG59XG5cbi8qXG4gVmlydHVhbCBkb20gaXMgYW4gYXJyYXkgb2YgY3VzdG9tIHRhZ3Mgb24gdGhlIGRvY3VtZW50LlxuIFVwZGF0ZXMgYW5kIHVubW91bnRzIHByb3BhZ2F0ZSBkb3dud2FyZHMgZnJvbSBwYXJlbnQgdG8gY2hpbGRyZW4uXG4qL1xuXG52YXIgdmlydHVhbERvbSA9IFtdLFxuICAgIHRhZ0ltcGwgPSB7fSxcbiAgICBzdHlsZU5vZGVcblxuXG5mdW5jdGlvbiBnZXRUYWcoZG9tKSB7XG4gIHJldHVybiB0YWdJbXBsW2RvbS5nZXRBdHRyaWJ1dGUoJ3Jpb3QtdGFnJykgfHwgZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKV1cbn1cblxuZnVuY3Rpb24gaW5qZWN0U3R5bGUoY3NzKSB7XG5cbiAgc3R5bGVOb2RlID0gc3R5bGVOb2RlIHx8IG1rRWwoJ3N0eWxlJylcblxuICBpZiAoIWRvY3VtZW50LmhlYWQpIHJldHVyblxuXG4gIGlmKHN0eWxlTm9kZS5zdHlsZVNoZWV0KVxuICAgIHN0eWxlTm9kZS5zdHlsZVNoZWV0LmNzc1RleHQgKz0gY3NzXG4gIGVsc2VcbiAgICBzdHlsZU5vZGUuaW5uZXJIVE1MICs9IGNzc1xuXG4gIGlmICghc3R5bGVOb2RlLl9yZW5kZXJlZClcbiAgICBpZiAoc3R5bGVOb2RlLnN0eWxlU2hlZXQpXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0eWxlTm9kZSlcbiAgICBlbHNlXG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlTm9kZSlcblxuICBzdHlsZU5vZGUuX3JlbmRlcmVkID0gdHJ1ZVxuXG59XG5cbmZ1bmN0aW9uIG1vdW50VG8ocm9vdCwgdGFnTmFtZSwgb3B0cykge1xuICB2YXIgdGFnID0gdGFnSW1wbFt0YWdOYW1lXSxcbiAgICAgIGlubmVySFRNTCA9IHJvb3QuaW5uZXJIVE1MXG5cbiAgLy8gY2xlYXIgdGhlIGlubmVyIGh0bWxcbiAgcm9vdC5pbm5lckhUTUwgPSAnJ1xuXG4gIGlmICh0YWcgJiYgcm9vdCkgdGFnID0gbmV3IFRhZyh0YWcsIHsgcm9vdDogcm9vdCwgb3B0czogb3B0cyB9LCBpbm5lckhUTUwpXG5cbiAgaWYgKHRhZyAmJiB0YWcubW91bnQpIHtcbiAgICB0YWcubW91bnQoKVxuICAgIHZpcnR1YWxEb20ucHVzaCh0YWcpXG4gICAgcmV0dXJuIHRhZy5vbigndW5tb3VudCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmlydHVhbERvbS5zcGxpY2UodmlydHVhbERvbS5pbmRleE9mKHRhZyksIDEpXG4gICAgfSlcbiAgfVxuXG59XG5cbnJpb3QudGFnID0gZnVuY3Rpb24obmFtZSwgaHRtbCwgY3NzLCBhdHRycywgZm4pIHtcbiAgaWYgKHR5cGVvZiBhdHRycyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBhdHRyc1xuICAgIGlmKC9eW1xcd1xcLV0rXFxzPz0vLnRlc3QoY3NzKSkge2F0dHJzID0gY3NzOyBjc3MgPSAnJ30gZWxzZSBhdHRycyA9ICcnXG4gIH1cbiAgaWYgKHR5cGVvZiBjc3MgPT0gJ2Z1bmN0aW9uJykgZm4gPSBjc3NcbiAgZWxzZSBpZiAoY3NzKSBpbmplY3RTdHlsZShjc3MpXG4gIHRhZ0ltcGxbbmFtZV0gPSB7IG5hbWU6IG5hbWUsIHRtcGw6IGh0bWwsIGF0dHJzOiBhdHRycywgZm46IGZuIH1cbiAgcmV0dXJuIG5hbWVcbn1cblxucmlvdC5tb3VudCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCB0YWdOYW1lLCBvcHRzKSB7XG5cbiAgdmFyIGVsLFxuICAgICAgc2VsY3RBbGxUYWdzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGFnSW1wbClcbiAgICAgICAgdmFyIGxpc3QgPSBrZXlzLmpvaW4oJywgJylcbiAgICAgICAgZWFjaChrZXlzLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgbGlzdCArPSAnLCAqW3Jpb3QtdGFnPVwiJysgdC50cmltKCkgKyAnXCJdJ1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gbGlzdFxuICAgICAgfSxcbiAgICAgIGFsbFRhZ3MsXG4gICAgICB0YWdzID0gW11cblxuICBpZiAodHlwZW9mIHRhZ05hbWUgPT0gJ29iamVjdCcpIHsgb3B0cyA9IHRhZ05hbWU7IHRhZ05hbWUgPSAwIH1cblxuICAvLyBjcmF3bCB0aGUgRE9NIHRvIGZpbmQgdGhlIHRhZ1xuICBpZih0eXBlb2Ygc2VsZWN0b3IgPT0gJ3N0cmluZycpIHtcbiAgICBpZiAoc2VsZWN0b3IgPT0gJyonKSB7XG4gICAgICAvLyBzZWxlY3QgYWxsIHRoZSB0YWdzIHJlZ2lzdGVyZWRcbiAgICAgIC8vIGFuZCBhbHNvIHRoZSB0YWdzIGZvdW5kIHdpdGggdGhlIHJpb3QtdGFnIGF0dHJpYnV0ZSBzZXRcbiAgICAgIHNlbGVjdG9yID0gYWxsVGFncyA9IHNlbGN0QWxsVGFncygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdG9yLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgc2VsZWN0b3IgKz0gJywgKltyaW90LXRhZz1cIicrIHQudHJpbSgpICsgJ1wiXSdcbiAgICAgIH0pXG5cbiAgICB9XG4gICAgLy8gb3IganVzdCB0aGUgb25lcyBuYW1lZCBsaWtlIHRoZSBzZWxlY3RvclxuICAgIGVsID0gJCQoc2VsZWN0b3IpXG4gIH1cbiAgLy8gcHJvYmFibHkgeW91IGhhdmUgcGFzc2VkIGFscmVhZHkgYSB0YWcgb3IgYSBOb2RlTGlzdFxuICBlbHNlXG4gICAgZWwgPSBzZWxlY3RvclxuXG4gIC8vIHNlbGVjdCBhbGwgdGhlIHJlZ2lzdGVyZWQgYW5kIG1vdW50IHRoZW0gaW5zaWRlIHRoZWlyIHJvb3QgZWxlbWVudHNcbiAgaWYgKHRhZ05hbWUgPT0gJyonKSB7XG4gICAgLy8gZ2V0IGFsbCBjdXN0b20gdGFnc1xuICAgIHRhZ05hbWUgPSBhbGxUYWdzIHx8IHNlbGN0QWxsVGFncygpXG4gICAgLy8gaWYgdGhlIHJvb3QgZWwgaXQncyBqdXN0IGEgc2luZ2xlIHRhZ1xuICAgIGlmIChlbC50YWdOYW1lKSB7XG4gICAgICBlbCA9ICQkKHRhZ05hbWUsIGVsKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZUxpc3QgPSBbXVxuICAgICAgLy8gc2VsZWN0IGFsbCB0aGUgY2hpbGRyZW4gZm9yIGFsbCB0aGUgZGlmZmVyZW50IHJvb3QgZWxlbWVudHNcbiAgICAgIGVhY2goZWwsIGZ1bmN0aW9uKHRhZykge1xuICAgICAgICBub2RlTGlzdCA9ICQkKHRhZ05hbWUsIHRhZylcbiAgICAgIH0pXG4gICAgICBlbCA9IG5vZGVMaXN0XG4gICAgfVxuICAgIC8vIGdldCByaWQgb2YgdGhlIHRhZ05hbWVcbiAgICB0YWdOYW1lID0gMFxuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChyb290KSB7XG4gICAgaWYodGFnTmFtZSAmJiAhcm9vdC5nZXRBdHRyaWJ1dGUoJ3Jpb3QtdGFnJykpIHJvb3Quc2V0QXR0cmlidXRlKCdyaW90LXRhZycsIHRhZ05hbWUpXG5cbiAgICB2YXIgbmFtZSA9IHRhZ05hbWUgfHwgcm9vdC5nZXRBdHRyaWJ1dGUoJ3Jpb3QtdGFnJykgfHwgcm9vdC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHRhZyA9IG1vdW50VG8ocm9vdCwgbmFtZSwgb3B0cylcblxuICAgIGlmICh0YWcpIHRhZ3MucHVzaCh0YWcpXG4gIH1cblxuICAvLyBET00gbm9kZVxuICBpZiAoZWwudGFnTmFtZSlcbiAgICBwdXNoKHNlbGVjdG9yKVxuICAvLyBzZWxlY3RvciBvciBOb2RlTGlzdFxuICBlbHNlXG4gICAgZWFjaChlbCwgcHVzaClcblxuICByZXR1cm4gdGFnc1xuXG59XG5cbi8vIHVwZGF0ZSBldmVyeXRoaW5nXG5yaW90LnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZWFjaCh2aXJ0dWFsRG9tLCBmdW5jdGlvbih0YWcpIHtcbiAgICB0YWcudXBkYXRlKClcbiAgfSlcbn1cblxuLy8gQGRlcHJlY2F0ZWRcbnJpb3QubW91bnRUbyA9IHJpb3QubW91bnRcblxuXG4gIC8vIHNoYXJlIG1ldGhvZHMgZm9yIG90aGVyIHJpb3QgcGFydHMsIGUuZy4gY29tcGlsZXJcbiAgcmlvdC51dGlsID0geyBicmFja2V0czogYnJhY2tldHMsIHRtcGw6IHRtcGwgfVxuXG4gIC8vIHN1cHBvcnQgQ29tbW9uSlMsIEFNRCAmIGJyb3dzZXJcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJpb3RcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHJpb3QgfSlcbiAgZWxzZVxuICAgIHdpbmRvdy5yaW90ID0gcmlvdFxuXG59KSh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jpb3QvcmlvdC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ])
});
;